# Welcome to pg-structure

**pg-structure** is a Node.js library to get structure of a [PostgreSQL](http://www.postgresql.org) database automatically as a detailed object.


<table style="border:none; border-spacing: 10px; border-collapse: separate;">
    <tr>
        <td style="width:28%; padding:10px 10px 10px 10px; border:1px solid #CCCCCC; background:#EEEEEE;">
            <strong>Tested</strong><br>
            Every part of the library is tested.
        </td>
        <td style="width:28%; padding:10px 10px 10px 10px; border:1px solid #CCCCCC; background:#EEEEEE;">
            <strong>Documented</strong><br>
            Everything is documented, no hidden features.
        </td>
        <td style="width:28%; padding:10px 10px 10px 10px; border:1px solid #CCCCCC; background:#EEEEEE;">
            <strong>Utilitarian</strong><br>
            Beyond database objects (i.e. <a href="api/m2m-relation">many to many relation</a>).
        </td>
    </tr>
</table>

pg-structure examines given PostgreSQL database by reverse engineering and lets you easily code, analyze, operate on PostgreSQL database structure by providing details about [DB](api/db.md), [Schema](api/schema.md), [Table](api/table.md), [Column](api/column.md), [Constraint](api/constraint.md) and [Relation](api/relation.md).

Created object can be used to auto generate documentation or ORM models from database. It is much easier to work with JS object than working manually with database.

## Example

    var pgStructure = require('pg-structure');
    
    pgStructure({database: 'db', user: 'user', password: 'password'}, ['public', 'other_schema'])
        .then((db) => { return db.get('public.account').columns; }

## Detailed Example

    var pgStructure = require('pg-structure');

    pgStructure({database: 'db', user: 'user', password: 'password', host: 'localhost', port: 5432}, ['public', 'other_schema'])
        .then((db) => {
            // Basic
            var tables      = db.getSchema('public').tables;    // Array of Table objects.
            var tableName   = tables[0].name;                   // Name of first table.
            
            // Callback
            db.getSchema('public').getTables(function(table, i, collection) {
                var name = table.name;
            });
            
            // Long chain example for:
            // public schema -> cart table -> contact_id columns -> foreign key constraint of contact_id
            // -> table of the constraint -> name of the referenced table
            var name     = db.get('public.cart.contact_id').foreignKeyConstraint.referencedTable.name;
            var sameName = db.getSchema('public').getTable('cart').getColumn('contact_id').foreignKeyConstraint.referencedTable.name;
            
            // Many to many relation:
            var joinTable = db.get('public.cart_line_item').m2mrelations[0].joinTable;
        })
        .catch((err) => {
            console.log(err);
        });

## Features

* Fully tested
* Fully documented with JSDOC and HTML (HTML docs are in doc directory)
* All PostgreSQL data types including array, JSON and HSTore
* Support composite keys (Multiple field keys)
* Schema support
* Constraints (Primary Key, Foreign Key, Unique).
* Supports multi-column constraints.
* Identifies one to many (hasMany) relationships.
* Identifies reverse of one to many (belongsTo) relationships
* Identifies all possible many to many (belongs to many & has many through) relationships
* Objects can be accessed by name or by order. (Contains object and array referencing to this objects fields)
* Objects can be iterated via callbacks.
* Very detailed column meta data:
    * Allow null
    * Description
    * Auto Increment
    * onUpdate
    * onDelete
    * etc. (Full details can be found in [Column](api/column.md) doc)

## Special Thanks
**pg-structure** is developed under sponsorship of [Fortibase](http://www.fortibase.com) and released as open source. See [license](license.md).

Also documentation is auto generated thanks to:

* [MkDocs](http://www.mkdocs.org/) using a [theme](https://github.com/snide/sphinx_rtd_theme) provided by [Read the Docs](https://readthedocs.org/).
* Markdown is generated by [jsdoc-to-markdown](https://www.npmjs.com/package/jsdoc-to-markdown)

## Contributions

* For contribution please send pull requests with tests on [GitHub](https://github.com/ozum/pg-structure.git).
* Send bugs and feature requests to [GitHub Issues](https://github.com/ozum/pg-structure/issues).


## Database Objects vs. pg-structure Objects

In this documentation **_database objects_** means database parts provided by PostgreSQL such as table, column, constraint etc. Sometimes those objects are simply refereed as _database_ as a general term in this documentation.

**_pg-structure objects_** means object instances provided by pg-structure classes.

## Objects (Instances)

In **pg-structure** database objects such as Schema, Column etc. are represented by JavaScript objects such as [Schema](api/schema.md), [Column](api/column.md) etc.

```js
pgStructure(connectionArgs, schemas).then((db) => {
    // db is an DB object.
});
```

## Attributes

**pg-structure** objects have read only attributes to access various database objects' details. Attributes are **read only** and formed as **nouns**.

* Singular named attributes such as [table#name](api/table.md#Table+name) contains single data which is a simple JavaScript type.
* Plural named attributes such as [table#columns](api/table.md#Table+columns) contains array of related objects.
* Plural named attributes with suffix `ByName` such as [table#columnsByName](api/table.md#Table+columnsByName) contains a simple object as key/value pairs. Keys are object's names, values are related objects.

## Methods

**pg-structure** also provides methods to access database details.

Most of the methods which returns array of objects have equivalent attributes. For example [table#columns](api/table.md#Table+columns) and [table#getColumns](api/table.md#Table+getColumns). They are provided for convenience. They may be called with callbacks or for their return value. Even some methods executes callbacks, pg-structure methods are synchronous. 

Methods are named as verbs like [Table#getPrimaryKeys](api/table.md#Table+getPrimaryKeys) or as question like terms such as [Column#isSerial](api/column.md#Column+isSerial) or [Table#columnExists](api/table.md#Table+columnExists).

## Callbacks

As described in previous section, some methods may be called with a callback function. They are executed synchronously for each object resulted by method call. Those are object collection returning functions. Their callback signature are usually `function (object, index, collection)`.

```js
schema.getTables(function(table, i, collection) {
//                          ↑    ↑        ^---- All tables of given schema.
//                          |    ------ Position of the table in array.
//                          ------ Individual table object.
    var name = table.name;
});
```

## `get` shortcut

[DB](api/db.md), [schema](api/schema.md), [table](api/table.md) classes provide `get` method for a shortcut. This method may be used to save a few key strokes.

For example all below are equal:

```js
var userColumn      = db.get('public.account.user_name');
var sameColumn      = db.getSchema('public').getTable('account').getColumn('user_name');
var againSameColumn = db.schemasByName.public.tablesByName.account.columnsByName.user_name;
```

## [Relation](api/relation.md) Classes vs. Foreign Key Constraint

**pg-structure** Foreign Key Constraint objects represent directly PostgreSQL foreign key constraints.

Developers and ORM users need to have more information about relations than present in foreign key constraints. For example many to many relationships and many to one relationships are not available in database engine. **pg-structure** provides [O2MRelation](api/o2m-relation.md), [M2MRelation](api/m2m-relation.md) and [M2ORelation](api/m2o-relation.md) classes to answer those needs.
## Modules
<dl>
<dt><a href="#module_pgStructrue">pgStructrue</a></dt>
<dd></dd>
</dl>
## Classes
<dl>
<dt><a href="#Column">Column</a></dt>
<dd><p>Class which represent a database column. Provides attributes and methods for details of the column.</p>
</dd>
<dt><a href="#Constraint">Constraint</a></dt>
<dd><p>Class which represent a constraint. Provides attributes and methods for details of the constraint.</p>
<h4 id="notes-for-through-constraints-span-id-notes-span-">Notes for Through Constraints <span id="notes"></span></h4>
<p>Through constraints are used for many to many relationships. Actually there isn&#39;t such a thing called
<strong>many to many relationship</strong> or <strong>through constraint</strong> in the database engine. They are concepts to describe
records which may be related more than one record on both sides. For example an invoice may contain more than product and
a product may related to more than one invoice. Those relationships are solved a so called many to many <strong>join table</strong>.</p>
<p>Constraint class supports many to many relationships. Since those constraints are not present in database engine,
they are extracted by estimation/interpretation. Many non-join tables in a database could have more than one
foreign key constraints, and they may not meant to be join tables, but they have still through relationships .</p>
<p><span id="exampleSchema"></span>Below is a database schema as an example:</p>
<pre><code>size -------------------
id (PK)                |  ---------------------------&lt; line_item &gt;------------ cart
name                   |  |                            product_id (PFK)        id (PK)
                       |  |                            cart_id    (PFK)        name
                       ^  |
color -------------&lt; product &gt;------------- vendor
id (PK)              id        (PK)         id (PK)
name                 name                   name
                     color_id  (FK)
                     size_id   (FK)
                     vendor_id (FK)
</code></pre><p>Below is the same schema as image:
<img src="../../images/schema-through.png" alt="Database Schema"></p>
<p>Product table has 3 foreign key constraints. It is obvious that product table is not meant to be a many to many join table.
However product could have been join table for <code>size &amp; vendor</code>, <code>color &amp; vendor</code> and <code>size &amp; color</code>. As a result size,
color and vendor tables would have many to many <code>through constraints</code>.</p>
</dd>
<dt><a href="#DB">DB</a></dt>
<dd><p>Class which represent a database. Provides attributes and methods for details of the database.</p>
</dd>
<dt><a href="#M2MRelation">M2MRelation</a> ⇐ <code><a href="#Relation">Relation</a></code></dt>
<dd></dd>
<dt><a href="#M2ORelation">M2ORelation</a> ⇐ <code><a href="#Relation">Relation</a></code></dt>
<dd></dd>
<dt><a href="#O2MRelation">O2MRelation</a> ⇐ <code><a href="#Relation">Relation</a></code></dt>
<dd></dd>
<dt><a href="#Relation">Relation</a></dt>
<dd><p>Base class for relations. Not used directly. See child classes.</p>
</dd>
<dt><a href="#Schema">Schema</a></dt>
<dd><p>Class which represent a PostgreSQL schema. Provides attributes and methods for details of the database.</p>
</dd>
<dt><a href="#Table">Table</a></dt>
<dd><p>Class which represent a table. Provides attributes and methods for details of the table. Tables have relationships
with other tables.</p>
<p><span id="exampleSchema"></span>Below is a database schema which is used in code examples.</p>
<pre><code>size -------------------
id (PK)                |  ---------------------------&lt; line_item &gt;------------ cart
name                   |  |                            product_id (PFK)        id (PK)
                       |  |                            cart_id    (PFK)        name
                       ^  |
color -------------&lt; product &gt;------------- vendor
id (PK)              id        (PK)         id (PK)
name                 name                   name
                     color_id  (FK)
                     size_id   (FK)
                     vendor_id (FK)
</code></pre><p>Below is the same schema as image:
<img src="../../images/schema-through.png" alt="Database Schema"></p>
</dd>
</dl>
## Members
<dl>
<dt><a href="#postgreSQLDataType">postgreSQLDataType</a> : <code>enum</code></dt>
<dd><p>PostgreSQL data types as returned by <a href="#Column+type">type</a>, <a href="Column#data_type">Column#data_type</a>, <a href="Column#udType">Column#udType</a>
<a href="#Column+userDefinedType">userDefinedType</a> and <a href="Column#udt_name">Column#udt_name</a>.</p>
</dd>
<dt><a href="#constraintRule">constraintRule</a> : <code>enum</code></dt>
<dd><p>Referential constraint rules.</p>
</dd>
</dl>
## Typedefs
<dl>
<dt><a href="#orderedSchemaCallback">orderedSchemaCallback</a> : <code>function</code></dt>
<dd><p>Callback function to execute for each <a href="#Schema">Schema</a> in an ordered collection.</p>
</dd>
<dt><a href="#orderedTableCallback">orderedTableCallback</a> : <code>function</code></dt>
<dd><p>Callback function to execute for each <a href="#Table">Table</a> in an ordered collection.</p>
</dd>
<dt><a href="#orderedColumnCallback">orderedColumnCallback</a> : <code>function</code></dt>
<dd><p>Callback function to execute for each <a href="#Column">Column</a> in an ordered collection.</p>
</dd>
<dt><a href="#orderedConstraintCallback">orderedConstraintCallback</a> : <code>function</code></dt>
<dd><p>Callback function to execute for each <a href="#Constraint">Constraint</a> in an ordered collection.</p>
</dd>
<dt><a href="#orderedRelationCallback">orderedRelationCallback</a> : <code>function</code></dt>
<dd><p>Callback function to execute for each <a href="#Relation">Relation</a> in an ordered collection.</p>
</dd>
</dl>
<a name="module_pgStructrue"></a>
## pgStructrue
<a name="module_pgStructrue..getDB"></a>
### pgStructrue~getDB(pgOptions, [schemas]) ⇒ <code>Promise.&lt;T&gt;</code>
**Kind**: inner method of <code>[pgStructrue](#module_pgStructrue)</code>  
**Returns**: <code>Promise.&lt;T&gt;</code> - - Promise with signature ([DB](#DB)).  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| pgOptions | <code>Object</code> &#124; <code>pg.client</code> |  | Pg client or Connection parameters to connect to database. |
| pgOptions.database | <code>string</code> |  | Database name |
| [pgOptions.host] | <code>string</code> | <code>&quot;localhost&quot;</code> | Hostname of the database. |
| [pgOptions.port] | <code>number</code> | <code>5432</code> | Port of the database. |
| [pgOptions.user] | <code>string</code> |  | Username for connecting to db. |
| [pgOptions.password] | <code>string</code> |  | Password to connecting to db. |
| [schemas] | <code>Array.&lt;string&gt;</code> | <code>[public]</code> | PostgreSQL schemas to be parsed. |

<a name="Column"></a>
## Column
Class which represent a database column. Provides attributes and methods for details of the column.

**Kind**: global class  

* [Column](#Column)
  * [new Column(args)](#new_Column_new)
  * [.allowNull](#Column+allowNull) : <code>boolean</code>
  * [.arrayDimension](#Column+arrayDimension) : <code>number</code>
  * [.arrayType](#Column+arrayType) : <code>string</code> &#124; <code>null</code>
  * [.db](#Column+db) : <code>[DB](#DB)</code>
  * [.default](#Column+default) : <code>string</code> &#124; <code>null</code>
  * [.defaultWithTypeCast](#Column+defaultWithTypeCast) : <code>string</code> &#124; <code>null</code>
  * [.description](#Column+description) : <code>string</code> &#124; <code>null</code>
  * [.domainName](#Column+domainName) : <code>string</code> &#124; <code>null</code>
  * [.domainFullName](#Column+domainFullName) : <code>string</code> &#124; <code>null</code>
  * [.enumLabels](#Column+enumLabels) : <code>Array.&lt;string&gt;</code> &#124; <code>null</code>
  * [.enumValues](#Column+enumValues) : <code>Array.&lt;string&gt;</code> &#124; <code>null</code>
  * [.foreignKeyConstraint](#Column+foreignKeyConstraint) : <code>[Constraint](#Constraint)</code> &#124; <code>null</code>
  * [.fullName](#Column+fullName) : <code>string</code>
  * [.fullCatalogName](#Column+fullCatalogName) : <code>string</code>
  * [.isAutoIncrement](#Column+isAutoIncrement) : <code>boolean</code>
  * [.isSerial](#Column+isSerial) : <code>boolean</code>
  * [.isForeignKey](#Column+isForeignKey) : <code>boolean</code>
  * [.isPrimaryKey](#Column+isPrimaryKey) : <code>boolean</code>
  * [.length](#Column+length) : <code>number</code> &#124; <code>null</code>
  * [.name](#Column+name) : <code>string</code>
  * [.notNull](#Column+notNull) : <code>boolean</code>
  * [.parent](#Column+parent) : <code>[Table](#Table)</code>
  * [.precision](#Column+precision) : <code>number</code> &#124; <code>null</code>
  * [.referencedColumn](#Column+referencedColumn) : <code>[Column](#Column)</code> &#124; <code>null</code>
  * [.scale](#Column+scale) : <code>number</code> &#124; <code>null</code>
  * [.schema](#Column+schema) : <code>[Schema](#Schema)</code>
  * [.type](#Column+type) : <code>[postgreSQLDataType](#postgreSQLDataType)</code>
  * [.table](#Column+table) : <code>[Table](#Table)</code>
  * [.userDefinedType](#Column+userDefinedType) : <code>[postgreSQLDataType](#postgreSQLDataType)</code> &#124; <code>null</code>
  * [.unique](#Column+unique) : <code>string</code> &#124; <code>null</code>

<a name="new_Column_new"></a>
### new Column(args)

| Param | Type | Description |
| --- | --- | --- |
| args | <code>Object</code> | Database arguments. |
| args.registry | <code>Loki</code> | Loki.js database object. |
| args.attributes | <code>Object</code> | Attributes of the [Column](#Column) instance. |

<a name="Column+allowNull"></a>
### column.allowNull : <code>boolean</code>
`true` if column is allowed to contain null values; otherwise `false`.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
**See**: [notNull](#Column+notNull).  
<a name="Column+arrayDimension"></a>
### column.arrayDimension : <code>number</code>
Number of dimensions, if the column is an array type; otherwise 0.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
<a name="Column+arrayType"></a>
### column.arrayType : <code>string</code> &#124; <code>null</code>
If this column is an array, data type of the array. If column is not an array equals `null`.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
<a name="Column+db"></a>
### column.db : <code>[DB](#DB)</code>
[DB](#DB) this table belongs to.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
<a name="Column+default"></a>
### column.default : <code>string</code> &#124; <code>null</code>
Default value of the column without typecast. Default values includes single quotes except sql functions and numeric values.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
**See**: [defaultWithTypeCast](#Column+defaultWithTypeCast) for default values with typecast as returned by PostgreSQL  
**Example**  
```js
var column = db('crm').schema('public').table('contact').column('name');
var type = column.default;           // "'George'"
type = age.default;                  // 20
type = created_at.default;           // "now()"
type = column.defaultWithTypeCast;   // "'George'::character varying"
```
<a name="Column+defaultWithTypeCast"></a>
### column.defaultWithTypeCast : <code>string</code> &#124; <code>null</code>
Default expression of the column with typecast. PostgreSQL returns default values with typecast.
Default values includes single quotes except sql functions and numeric values. Also sql functions and numeric values
do not contain type cast.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
**See**: [default](#Column+default) for accessing default values without typecast.  
**Example**  
```js
var column = db('crm').schema('public').table('contact').column('name');
var type = column.defaultWithTypeCast;   // "'George'::character varying"
type = age.defaultWithTypeCast;          // 20
type = created_at.defaultWithTypeCast;   // "now()"
type = column.default;                   // "'George'"
```
<a name="Column+description"></a>
### column.description : <code>string</code> &#124; <code>null</code>
Comment about column.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
<a name="Column+domainName"></a>
### column.domainName : <code>string</code> &#124; <code>null</code>
If column data type is is a domain, this equals domain name without domain schema. Otherwise null.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
**See**: [domainFullName](#Column+domainFullName).  
**Example**  
```js
var domainName = column.domainName; // i.e. 'phone_number'
```
<a name="Column+domainFullName"></a>
### column.domainFullName : <code>string</code> &#124; <code>null</code>
If column data type is is a domain, this equals domain name including domain schema. Otherwise null.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
**See**: [domainName](#Column+domainName).  
**Example**  
```js
var domainName = column.domainFullName; // i.e. 'public.phone_number'
```
<a name="Column+enumLabels"></a>
### column.enumLabels : <code>Array.&lt;string&gt;</code> &#124; <code>null</code>
Array of the textual labels for enum values column may contain. If column is not an enum, then this
equals `undefined`

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
**See**: Aliases [enumValues](#Column+enumValues)  
<a name="Column+enumValues"></a>
### column.enumValues : <code>Array.&lt;string&gt;</code> &#124; <code>null</code>
Array of the textual labels for enum values column may contain. If column is not an enum, then this
equals `undefined`

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
**See**: Aliases [enumLabels](#Column+enumLabels)  
<a name="Column+foreignKeyConstraint"></a>
### column.foreignKeyConstraint : <code>[Constraint](#Constraint)</code> &#124; <code>null</code>
Foreign key constraint of the column, if column is part of a foreign key constraint, null otherwise.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
<a name="Column+fullName"></a>
### column.fullName : <code>string</code>
Full name of the [Column](#Column) with (.) notation.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
**Example**  
```js
var fullName = column.fullName; // public.account.id
```
<a name="Column+fullCatalogName"></a>
### column.fullCatalogName : <code>string</code>
Full name of the [Column](#Column) with (.) notation including catalog name.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
**Example**  
```js
var fullName = table.fullName; // crm.public.account.id
```
<a name="Column+isAutoIncrement"></a>
### column.isAutoIncrement : <code>boolean</code>
`true` if this column has an auto incremented (`nextval()`) default value or defined one of `serial`
types.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
**See**: Aliases [isSerial](#Column+isSerial)  
<a name="Column+isSerial"></a>
### column.isSerial : <code>boolean</code>
`true` if this column has an auto incremented (`nextval()`) default value or defined one of `serial`
types.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
**See**: Aliases [isAutoIncrement](#Column+isAutoIncrement)  
<a name="Column+isForeignKey"></a>
### column.isForeignKey : <code>boolean</code>
`true` if this column is a foreign key or part of a foreign key constraint; otherwise `false`.
Please note that a foreign key may contain more than one column.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
<a name="Column+isPrimaryKey"></a>
### column.isPrimaryKey : <code>boolean</code>
`true` if this column is a primary key or part of a primary key constraint; otherwise `false`.
Please note that a primary key may contain more than one column.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
<a name="Column+length"></a>
### column.length : <code>number</code> &#124; <code>null</code>
Length of the column.
* For data type identified as a character or bit string type, this is the declared
maximum length. If column is an array, same rule applies data type of the array.
* For character arrays or bit string type arrays, this is the declared maximum length of the array's data type.
* For arrays atttypmod records type-specific data supplied at table creation time (for example, the maximum length
of a varchar column). It is passed to type-specific input functions and length coercion functions.
* This value is `undefined` for all other data types or if no maximum length was declared.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
<a name="Column+name"></a>
### column.name : <code>string</code>
Name of the column.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
<a name="Column+notNull"></a>
### column.notNull : <code>boolean</code>
`true` if column is **not allowed** to contain null values; otherwise `false`.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
**See**: [allowNull](#Column+allowNull)  
<a name="Column+parent"></a>
### column.parent : <code>[Table](#Table)</code>
[Table](#Table) this column belongs to.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
**See**: Aliases [table](#Column+table)  
**Example**  
```js
var table = column.parent; // Table instance
```
<a name="Column+precision"></a>
### column.precision : <code>number</code> &#124; <code>null</code>
* If data type identifies a numeric type, this contains the (declared or implicit) precision of
the type for this column. The precision indicates the number of significant digits.
* If data type identifies a date, time, timestamp, or interval type, this column contains the (declared or implicit)
fractional seconds precision of the type for this attribute, that is, the number of decimal digits maintained
following the decimal point in the seconds value.
* If data type is an array. Same rules apply for the data type of the array, and this value would become precision
of the data type of the array.
* For all other data types, this is `undefined`.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
<a name="Column+referencedColumn"></a>
### column.referencedColumn : <code>[Column](#Column)</code> &#124; <code>null</code>
Referenced column by this column. If this isn't foreign key then this is null.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
<a name="Column+scale"></a>
### column.scale : <code>number</code> &#124; <code>null</code>
* If data type identifies an exact numeric type, this contains the (declared or implicit) scale
of the type for this attribute. The scale indicates the number of significant digits to the right of the decimal point.
* If data type is an array. Same rule applies for the data type of the array, and this value would become scale
of the data type of the array.
* For all other data types, this is `undefined`.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
<a name="Column+schema"></a>
### column.schema : <code>[Schema](#Schema)</code>
[Schema](#Schema) this column belongs to.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
<a name="Column+type"></a>
### column.type : <code>[postgreSQLDataType](#postgreSQLDataType)</code>
Data type of the column.
* For built-in types this is name of type.
* `ARRAY`, for arrays, and type of array can be found via [arrayType](#Column+arrayType).
* `USER-DEFINED` for user defined types, and type of it can be found via [userDefinedType](#Column+userDefinedType).
* For domain types this is not domain name, but underlying base type of that domain. Use [domainName](#Column+domainName) or [domainFullName](#Column+domainFullName)

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
**See**

- [userDefinedType](#Column+userDefinedType)
- [domainName](#Column+domainName) and [domainFullName](#Column+domainFullName)

<a name="Column+table"></a>
### column.table : <code>[Table](#Table)</code>
[Table](#Table) this column belongs to.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
**See**: Aliases [parent](#Column+parent)  
**Example**  
```js
var table = column.table; // Table instance
```
<a name="Column+userDefinedType"></a>
### column.userDefinedType : <code>[postgreSQLDataType](#postgreSQLDataType)</code> &#124; <code>null</code>
If type of column is user defined such as composite, enumerated, this is the data type of the underlying type.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
<a name="Column+unique"></a>
### column.unique : <code>string</code> &#124; <code>null</code>
If column is unique or part of a unique constraint returns constraint name, otherwise null.
Also adding a unique constraint to a column will automatically create a unique btree index on the column
or group of columns used in the constraint. As a result this attribute includes all.

**Kind**: instance property of <code>[Column](#Column)</code>  
**Read only**: true  
<a name="Constraint"></a>
## Constraint
Class which represent a constraint. Provides attributes and methods for details of the constraint.

#### Notes for Through Constraints <span id="notes"></span>
Through constraints are used for many to many relationships. Actually there isn't such a thing called
**many to many relationship** or **through constraint** in the database engine. They are concepts to describe
records which may be related more than one record on both sides. For example an invoice may contain more than product and
a product may related to more than one invoice. Those relationships are solved a so called many to many **join table**.

Constraint class supports many to many relationships. Since those constraints are not present in database engine,
they are extracted by estimation/interpretation. Many non-join tables in a database could have more than one
foreign key constraints, and they may not meant to be join tables, but they have still through relationships .

<span id="exampleSchema"></span>Below is a database schema as an example:
```
size -------------------
id (PK)                |  ---------------------------< line_item >------------ cart
name                   |  |                            product_id (PFK)        id (PK)
                       |  |                            cart_id    (PFK)        name
                       ^  |
color -------------< product >------------- vendor
id (PK)              id        (PK)         id (PK)
name                 name                   name
                     color_id  (FK)
                     size_id   (FK)
                     vendor_id (FK)
```
Below is the same schema as image:
![Database Schema](../../images/schema-through.png)

Product table has 3 foreign key constraints. It is obvious that product table is not meant to be a many to many join table.
However product could have been join table for `size & vendor`, `color & vendor` and `size & color`. As a result size,
color and vendor tables would have many to many `through constraints`.

**Kind**: global class  

* [Constraint](#Constraint)
  * [new Constraint(args)](#new_Constraint_new)
  * [.name](#Constraint+name) : <code>string</code>
  * [.fullName](#Constraint+fullName) : <code>string</code>
  * [.fullCatalogName](#Constraint+fullCatalogName) : <code>string</code>
  * [.type](#Constraint+type) : <code>contsraintType</code>
  * [.child](#Constraint+child) : <code>[Table](#Table)</code>
  * [.table](#Constraint+table) : <code>[Table](#Table)</code>
  * [.db](#Constraint+db) : <code>[DB](#DB)</code>
  * [.schema](#Constraint+schema) : <code>[Schema](#Schema)</code>
  * [.onUpdate](#Constraint+onUpdate) : <code>[constraintRule](#constraintRule)</code> &#124; <code>null</code>
  * [.onDelete](#Constraint+onDelete) : <code>[constraintRule](#constraintRule)</code> &#124; <code>null</code>
  * [.referencedTable](#Constraint+referencedTable) : <code>[Table](#Table)</code> &#124; <code>null</code>
  * [.parent](#Constraint+parent) : <code>[Table](#Table)</code> &#124; <code>null</code>
  * [.columns](#Constraint+columns) : <code>[Array.&lt;Column&gt;](#Column)</code> &#124; <code>null</code>
  * [.columnsByName](#Constraint+columnsByName) : <code>Object.&lt;string, Column&gt;</code> &#124; <code>null</code>

<a name="new_Constraint_new"></a>
### new Constraint(args)

| Param | Type | Description |
| --- | --- | --- |
| args | <code>Object</code> | Constraint arguments. |
| args.registry | <code>Loki</code> | Loki.js database object. |
| args.attributes | <code>Object</code> | Attributes of the [Constraint](#Constraint) instance. |

<a name="Constraint+name"></a>
### constraint.name : <code>string</code>
Name of the constraint.

**Kind**: instance property of <code>[Constraint](#Constraint)</code>  
**Read only**: true  
<a name="Constraint+fullName"></a>
### constraint.fullName : <code>string</code>
Full name of the [constraint](#Constraint) with (.) notation.

**Kind**: instance property of <code>[Constraint](#Constraint)</code>  
**Read only**: true  
**Example**  
```js
var fullName = constraint.fullName; // crm.public
```
<a name="Constraint+fullCatalogName"></a>
### constraint.fullCatalogName : <code>string</code>
Full name of the [constraint](#Constraint) with (.) notation including catalog name.

**Kind**: instance property of <code>[Constraint](#Constraint)</code>  
**Read only**: true  
**Example**  
```js
var fullCatalogName = constraint.fullCatalogName; // crm.public
```
<a name="Constraint+type"></a>
### constraint.type : <code>contsraintType</code>
Constraint type. One of `PRIMARY KEY`, `FOREIGN KEY` or `CHECK`

**Kind**: instance property of <code>[Constraint](#Constraint)</code>  
**Read only**: true  
<a name="Constraint+child"></a>
### constraint.child : <code>[Table](#Table)</code>
Child [table](#Table) of this [contraint](#Constraint).
**Note for foreign key constraints:** Child table is the table which contains foreign key.
In [example schema](#exampleSchema) product is a child table (vendor_id FK) of vendor table.

**Kind**: instance property of <code>[Constraint](#Constraint)</code>  
**Read only**: true  
**Example**  
```js
var table = constraint.child;
```
<a name="Constraint+table"></a>
### constraint.table : <code>[Table](#Table)</code>
[Table](#Table) which this [contraint](#Constraint) belongs to or defined in. <br>
**Note for foreign key constraints:** As usual PostgreSQL defines foreign key constraints in child tables,
where foreign key column is defined, so this is child table for foreign key constraints.

**Kind**: instance property of <code>[Constraint](#Constraint)</code>  
**Read only**: true  
**Example**  
```js
var table = constraint.table;
```
<a name="Constraint+db"></a>
### constraint.db : <code>[DB](#DB)</code>
[DB](#DB) this [contraint](#Constraint) belongs to.

**Kind**: instance property of <code>[Constraint](#Constraint)</code>  
**Read only**: true  
<a name="Constraint+schema"></a>
### constraint.schema : <code>[Schema](#Schema)</code>
[Schema](#Schema) this [contraint](#Constraint) belongs to.

**Kind**: instance property of <code>[Constraint](#Constraint)</code>  
**Read only**: true  
<a name="Constraint+onUpdate"></a>
### constraint.onUpdate : <code>[constraintRule](#constraintRule)</code> &#124; <code>null</code>
Update rule for foreign key [contraints](#Constraint). One of `CASCADE`, `SET NULL`, `SET DEFAULT`, `RESTRICT`, `NO ACTION`
If this is not a foreign key [contraint](#Constraint) this is `null`.

**Kind**: instance property of <code>[Constraint](#Constraint)</code>  
**Read only**: true  
<a name="Constraint+onDelete"></a>
### constraint.onDelete : <code>[constraintRule](#constraintRule)</code> &#124; <code>null</code>
Update rule for foreign key [contraints](#Constraint). One of `CASCADE`, `SET NULL`, `SET DEFAULT`, `RESTRICT`, `NO ACTION`
If this is not a foreign key [contraint](#Constraint) this is `null`.

**Kind**: instance property of <code>[Constraint](#Constraint)</code>  
**Read only**: true  
<a name="Constraint+referencedTable"></a>
### constraint.referencedTable : <code>[Table](#Table)</code> &#124; <code>null</code>
For foreign key [contraints](#Constraint) this is [Table](#Table) instance this [contraint](#Constraint) refers to.
If this is not a foreign key [contraint](#Constraint) this is `null`.

**Kind**: instance property of <code>[Constraint](#Constraint)</code>  
**Read only**: true  
**See**: Aliases [parent](#Constraint+parent)  
<a name="Constraint+parent"></a>
### constraint.parent : <code>[Table](#Table)</code> &#124; <code>null</code>
For foreign key [contraints](#Constraint) this is [Table](#Table) instance this [contraint](#Constraint) refers to.
If this is not a foreign key [contraint](#Constraint) this is `null`. <br>
**Please Note:** This is not the [Table](#Table) this constraint belongs to or defined in. Parent applies only to
foreign key constraints and for foreign key constraints parent means referenced table not the table it is defined in.

**Kind**: instance property of <code>[Constraint](#Constraint)</code>  
**Read only**: true  
**See**

- Aliases [referencedTable](#Constraint+referencedTable)
- To get [Table](#Table) this constraint belongs to or defined in, use [table](#Constraint+table).

<a name="Constraint+columns"></a>
### constraint.columns : <code>[Array.&lt;Column&gt;](#Column)</code> &#124; <code>null</code>
List of [columns](#Column) restricted by [contraint](#Constraint), in order their ordinal position
within the constraint key. If [constraint](#Constraint) does not have any [columns](#Column) this is `null`.

**Kind**: instance property of <code>[Constraint](#Constraint)</code>  
**Read only**: true  
<a name="Constraint+columnsByName"></a>
### constraint.columnsByName : <code>Object.&lt;string, Column&gt;</code> &#124; <code>null</code>
List of columns restricted by [contraint](#Constraint), in order their ordinal position within the constraint key.
If [contraint](#Constraint) does not have any columns this is `null`.

**Kind**: instance property of <code>[Constraint](#Constraint)</code>  
**Read only**: true  
<a name="DB"></a>
## DB
Class which represent a database. Provides attributes and methods for details of the database.

**Kind**: global class  

* [DB](#DB)
  * [new DB(args)](#new_DB_new)
  * [.name](#DB+name) : <code>string</code>
  * [.fullName](#DB+fullName) : <code>string</code>
  * [.fullCatalogName](#DB+fullCatalogName) : <code>string</code>
  * [.schemas](#DB+schemas) : <code>[Array.&lt;Schema&gt;](#Schema)</code> &#124; <code>null</code>
  * [.schemasByName](#DB+schemasByName) : <code>Object.&lt;string, Schema&gt;</code> &#124; <code>null</code>
  * [.schemasByName](#DB+schemasByName) : <code>Object.&lt;string, Schema&gt;</code> &#124; <code>null</code>
  * [.getSchema(key)](#DB+getSchema) ⇒ <code>[Schema](#Schema)</code> &#124; <code>undefined</code>
  * [.schemaExists(name)](#DB+schemaExists) ⇒ <code>boolean</code>
  * [.get(path)](#DB+get) ⇒ <code>[Schema](#Schema)</code> &#124; <code>[Table](#Table)</code> &#124; <code>[Column](#Column)</code> &#124; <code>undefined</code>
  * [.getSchemas([callback])](#DB+getSchemas) ⇒ <code>[Array.&lt;Schema&gt;](#Schema)</code> &#124; <code>undefined</code> &#124; <code>null</code>

<a name="new_DB_new"></a>
### new DB(args)

| Param | Type | Description |
| --- | --- | --- |
| args | <code>Object</code> | Database arguments. |
| args.registry | <code>Loki</code> | Loki.js database object. |
| args.attributes | <code>Object</code> | Attributes of the [DB](#DB) instance. |

<a name="DB+name"></a>
### dB.name : <code>string</code>
Name of the [Database](Database).

**Kind**: instance property of <code>[DB](#DB)</code>  
**Read only**: true  
<a name="DB+fullName"></a>
### dB.fullName : <code>string</code>
Full name of the [Database](Database) with (.) notation. Since database does not have a parent this equals database name.

**Kind**: instance property of <code>[DB](#DB)</code>  
**Read only**: true  
<a name="DB+fullCatalogName"></a>
### dB.fullCatalogName : <code>string</code>
Full name of the [Database](Database) with (.) notation including catalog name. Since database does not have a parent this equals database name.

**Kind**: instance property of <code>[DB](#DB)</code>  
**Read only**: true  
<a name="DB+schemas"></a>
### dB.schemas : <code>[Array.&lt;Schema&gt;](#Schema)</code> &#124; <code>null</code>
All [Schema](#Schema) instances in the database as an array. They are ordered by schema name.

**Kind**: instance property of <code>[DB](#DB)</code>  
**Read only**: true  
**Example**  
```js
var schemas = db.schemas;
var name    = schemas[0].name;
```
<a name="DB+schemasByName"></a>
### dB.schemasByName : <code>Object.&lt;string, Schema&gt;</code> &#124; <code>null</code>
All [Schema](#Schema) instances in the database as a simple object. Keys are schema names, values are [Schema](#Schema) instances.

**Kind**: instance property of <code>[DB](#DB)</code>  
**Read only**: true  
**Example**  
```js
var schemas = db.schemasByName;
var public  = schemas.public;
```
<a name="DB+schemasByName"></a>
### dB.schemasByName : <code>Object.&lt;string, Schema&gt;</code> &#124; <code>null</code>
All [Schema](#Schema) instances in the database as a simple object. Keys are schema names, values are [Schema](#Schema) instances.

**Kind**: instance property of <code>[DB](#DB)</code>  
**Read only**: true  
**Example**  
```js
var schemas = db.schemasByName;
var public  = schemas.public;
```
<a name="DB+getSchema"></a>
### dB.getSchema(key) ⇒ <code>[Schema](#Schema)</code> &#124; <code>undefined</code>
Returns [Schema](#Schema) instance with given name or order.

**Kind**: instance method of <code>[DB](#DB)</code>  
**Returns**: <code>[Schema](#Schema)</code> &#124; <code>undefined</code> - - Requested [Schema](#Schema) instance.  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>string</code> &#124; <code>number</code> | Name or order number of the schema. |

**Example**  
```js
var schema = db.getSchema('public');
```
<a name="DB+schemaExists"></a>
### dB.schemaExists(name) ⇒ <code>boolean</code>
Returns true if [Schema](#Schema) instance with given name or order number exists.

**Kind**: instance method of <code>[DB](#DB)</code>  
**Returns**: <code>boolean</code> - - `true` if schema exists in database, otherwise `false`.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> &#124; <code>number</code> | Name or order number of the schema. |

**Example**  
```js
var publicExists = db.schemaExists('public'); // true
var otherExists  = db.schemaExists('other');  // false
```
<a name="DB+get"></a>
### dB.get(path) ⇒ <code>[Schema](#Schema)</code> &#124; <code>[Table](#Table)</code> &#124; <code>[Column](#Column)</code> &#124; <code>undefined</code>
Returns [Schema](#Schema), [Table](#Table) or [Column](#Column) on given path relative to [DB](#DB). Path should be in dot (.) notation.

**Kind**: instance method of <code>[DB](#DB)</code>  
**Returns**: <code>[Schema](#Schema)</code> &#124; <code>[Table](#Table)</code> &#124; <code>[Column](#Column)</code> &#124; <code>undefined</code> - - Requested item.  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>string</code> | Path of the requested item in dot (.) notation such as 'public.contact' |

**Example**  
```js
var schema = db.get('public'),              // Returns public schema.
    table  = db.get('public.contact'),      // Returns contact table in public schema.
    column = db.get('public.contact.name'); // Returns name column of the contact table in public schema.
```
<a name="DB+getSchemas"></a>
### dB.getSchemas([callback]) ⇒ <code>[Array.&lt;Schema&gt;](#Schema)</code> &#124; <code>undefined</code> &#124; <code>null</code>
Retrieves all schemas in the database and executes given callback (sync), if provided. Callback has a signature of
([Schema](#Schema), index, collection). If no callback is provided, returns an array of all [schemas](#Schema).

**Kind**: instance method of <code>[DB](#DB)</code>  

| Param | Type | Description |
| --- | --- | --- |
| [callback] | <code>[orderedSchemaCallback](#orderedSchemaCallback)</code> | Callback to be executed for each schema. |

**Example**  
```js
db.getSchemas(function(schema, i, collection) {
    var name = schema.name;
    var ord  = i;
);
```
<a name="M2MRelation"></a>
## M2MRelation ⇐ <code>[Relation](#Relation)</code>
**Kind**: global class  
**Extends:** <code>[Relation](#Relation)</code>  

* [M2MRelation](#M2MRelation) ⇐ <code>[Relation](#Relation)</code>
  * [new M2MRelation()](#new_M2MRelation_new)
  * [.type](#M2MRelation+type) : <code>relationType</code>
  * [.sourceTable](#M2MRelation+sourceTable) : <code>[Table](#Table)</code>
  * [.joinTable](#M2MRelation+joinTable) : <code>[Table](#Table)</code>
  * [.targetTable](#M2MRelation+targetTable) : <code>[Table](#Table)</code>
  * [.sourceConstraint](#M2MRelation+sourceConstraint) : <code>[Table](#Table)</code>
  * [.targetConstraint](#M2MRelation+targetConstraint) : <code>[Table](#Table)</code>

<a name="new_M2MRelation_new"></a>
### new M2MRelation()
Class which represent a many to many relationship which resembles `belongsToMany` or `hasManyThrough` relations in ORMs (Object Relational Mappers).
Provides attributes and methods for details of the relationship.

Actually there isn't such a thing called **many to many relationship** or **through constraint** in the database engine.
They are concepts to describe records which may be related more than one record on both sides.
For example an invoice may contain more than product and a product may related to more than one invoice.
Those relationships are solved a so called many to many **join table**.

Since those relations are not present in database engine, they are extracted by estimation/interpretation.
Many non-join tables in a database could have more than one foreign key constraints,
and they may not meant to be join tables, but they still appear to have through relationships.

<span id="exampleSchema"></span>Below is a database schema as an example:
```
size -------------------
id (PK)                |  ---------------------------< line_item >------------ cart
name                   |  |                            product_id (PFK)        id (PK)
                       |  |                            cart_id    (PFK)        name
                       ^  |
color -------------< product >------------- vendor
id (PK)              id        (PK)         id (PK)
name                 name                   name
                     color_id  (FK)
                     size_id   (FK)
                     vendor_id (FK)

```
Below is the same schema as image:
![Database Schema](../../images/schema-through.png)

Some definitions used in descriptions for [M2MRelation](#M2MRelation).
* ** Source Table: ** Table which this relationship belongs to.
* ** Join Table: ** Table that contains common fields from two or more other tables.
* ** Target Table: ** Table that is related to base table through a join table.
<br><br>
Product table has 3 foreign key constraints. Product table is not meant to be a many to many join table.
However product could have been join table for `size & vendor`, `color & vendor` and `size & color`. As a result size,
color and vendor tables would have many to many relationships.

**Example**  
```js
// Example tables have single primary key and and examples first relation. So zero index ([0]) is used. Use all array elements if necessary.
// product ----< line_item >---- cart
// (source)        (join)       (target)

let relation             = product.m2mRelations[0];              // RELATION:    product ---< line_item >--- cart
let sourceConstraint     = relation.sourceConstraint;            // CONSTRAINT:           ^-- product_has_carts
let targetConstraint     = relation.targetConstraint;            // CONSTRAINT:       cart_has_products --^
let sourceTable          = relation.sourceTable;                 // TABLE:       product
let targetTable          = relation.targetTable;                 // TABLE:       cart
let sourceJoinFKColumn   = relation.sourceConstraint.columns[0]; // COLUMN:      product_id  (from line_item table)
let targetJoinFKColumn   = relation.targetConstraint.columns[0]; // COLUMN:      cart_id     (from line_item table)
let sourcePKColumn       = relation.sourceTable.primaryKeys[0];  // COLUMN:      id          (from product table)
let targetPKColumn       = relation.targetTable.primaryKeys[0];  // COLUMN:      id          (from cart table)
```
<a name="M2MRelation+type"></a>
### m2MRelation.type : <code>relationType</code>
Type of relation. One of `ONE TO MANY` or `MANY TO MANY`.

**Kind**: instance property of <code>[M2MRelation](#M2MRelation)</code>  
**Read only**: true  
<a name="M2MRelation+sourceTable"></a>
### m2MRelation.sourceTable : <code>[Table](#Table)</code>
[Table](#Table) which this relation belongs to.

**Kind**: instance property of <code>[M2MRelation](#M2MRelation)</code>  
**Read only**: true  
**Example**  
```js
let relation = product.M2MRelationRelations[0];  // RELATION:    product ---< line_item >--- cart
let source   = relation.sourceTable;             // TABLE:       product
```
<a name="M2MRelation+joinTable"></a>
### m2MRelation.joinTable : <code>[Table](#Table)</code>
[Table](#Table) of this relationship. This table contains foreign key columns referring both
[sourceTable](#M2MRelation+sourceTable) and [targetTable](#M2MRelation+targetTable).

**Kind**: instance property of <code>[M2MRelation](#M2MRelation)</code>  
**Read only**: true  
**Example**  
```js
let relation  = product.M2MRelationRelations[0]; // RELATION:    product ---< line_item >--- cart
let joinTable = relation.joinTable;              // TABLE:       line_item
```
<a name="M2MRelation+targetTable"></a>
### m2MRelation.targetTable : <code>[Table](#Table)</code>
[Table](#Table) which this relation is referring to (Through a join table).

**Kind**: instance property of <code>[M2MRelation](#M2MRelation)</code>  
**Read only**: true  
**Example**  
```js
let relation = product.M2MRelationRelations[0];  // RELATION:    product ---< line_item >--- cart
let target   = relation.targetTable;             // TABLE:       cart
```
<a name="M2MRelation+sourceConstraint"></a>
### m2MRelation.sourceConstraint : <code>[Table](#Table)</code>
Foreign key [constraint](#Constraint) between [source table](#M2MRelation+sourceTable) and [join table](#M2MRelation+joinTable).

**Kind**: instance property of <code>[M2MRelation](#M2MRelation)</code>  
**Read only**: true  
**Example**  
```js
let relation             = product.M2MRelationRelations[0];      // RELATION:    product ---< line_item >--- cart
let sourceConstraint     = relation.sourceConstraint;            // CONSTRAINT:           ^-- product_has_carts
let sourceJoinFKColumn   = relation.sourceConstraint.columns[0]; // COLUMN:      product_id (from line_item table)
```
<a name="M2MRelation+targetConstraint"></a>
### m2MRelation.targetConstraint : <code>[Table](#Table)</code>
Foreign key [constraint](#Constraint) between [join table](#M2MRelation+joinTable) and [target table](#M2MRelation+targetTable).

**Kind**: instance property of <code>[M2MRelation](#M2MRelation)</code>  
**Read only**: true  
**Example**  
```js
let relation             = product.M2MRelationRelations[0];      // RELATION:    product ---< line_item >--- cart
let targetConstraint     = relation.targetConstraint;            // CONSTRAINT:       cart_has_products --^
let targetJoinFKColumn   = relation.targetConstraint.columns[0]; // COLUMN:      cart_id (from line_item table)
```
<a name="M2ORelation"></a>
## M2ORelation ⇐ <code>[Relation](#Relation)</code>
**Kind**: global class  
**Extends:** <code>[Relation](#Relation)</code>  

* [M2ORelation](#M2ORelation) ⇐ <code>[Relation](#Relation)</code>
  * [new M2ORelation()](#new_M2ORelation_new)
  * [.type](#M2ORelation+type) : <code>relationType</code>
  * [.sourceTable](#M2ORelation+sourceTable) : <code>[Table](#Table)</code>
  * [.targetTable](#M2ORelation+targetTable) : <code>[Table](#Table)</code>
  * [.constraint](#M2ORelation+constraint) : <code>[Table](#Table)</code>

<a name="new_M2ORelation_new"></a>
### new M2ORelation()
Class which represent many to one relationship which resembles `belongsTo` relation in ORMs (Object Relational Mappers).
Provides attributes and methods for details of the relationship.

Actually there is no many to one relation in database engine. It is basically one to many relation in reverse direction.

<span id="exampleSchema"></span>Below is a database schema as an example:
```
size -------------------
id (PK)                |  ---------------------------< line_item >------------ cart
name                   |  |                            product_id (PFK)        id (PK)
                       |  |                            cart_id    (PFK)        name
                       ^  |
color -------------< product >------------- vendor
id (PK)              id        (PK)         id (PK)
name                 name                   name
                     color_id  (FK)
                     size_id   (FK)
                     vendor_id (FK)

```
Below is the same schema as image:
![Database Schema](../../images/schema-through.png)

Some definitions used in descriptions for [M2ORelation](#M2ORelation).
* ** Source Table: ** Table which this relationship belongs to.
* ** Target Table: ** Table that is related to base table.

**Example**  
```js
// Example tables have single primary key and examples first relation. So zero index ([0]) is used. Use all array elements if necessary.
// line_item >---- product
// (source)        (target)

let relation     = line_item.m2oRelations[0];            // RELATION:    line_item >---- product
let constraint   = relation.constraint;                  // CONSTRAINT:               ^-- product_has_carts
let sourceTable  = relation.sourceTable;                 // TABLE:       line_item
let targetTable  = relation.targetTable;                 // TABLE:       product
let FKColumn     = relation.constraint.columns[0];       // COLUMN:      product_id  (from line_item table)
let PKColumn     = relation.targetTable.primaryKeys[0];  // COLUMN:      id          (from product table)
```
<a name="M2ORelation+type"></a>
### m2ORelation.type : <code>relationType</code>
Type of relation. One of `ONE TO MANY` or `MANY TO MANY`.

**Kind**: instance property of <code>[M2ORelation](#M2ORelation)</code>  
**Read only**: true  
<a name="M2ORelation+sourceTable"></a>
### m2ORelation.sourceTable : <code>[Table](#Table)</code>
[Table](#Table) which this relation belongs to.

**Kind**: instance property of <code>[M2ORelation](#M2ORelation)</code>  
**Read only**: true  
**Example**  
```js
let relation     = product.M2ORelationRelations[0];  // RELATION:    line_item >---- product
let sourceTable  = relation.sourceTable;             // TABLE:       line_item
```
<a name="M2ORelation+targetTable"></a>
### m2ORelation.targetTable : <code>[Table](#Table)</code>
[Table](#Table) which this relation is referred by.

**Kind**: instance property of <code>[M2ORelation](#M2ORelation)</code>  
**Read only**: true  
**Example**  
```js
let relation     = product.M2ORelationRelations[0];  // RELATION:    line_item >---- product
let targetTable  = relation.targetTable;             // TABLE:       product
```
<a name="M2ORelation+constraint"></a>
### m2ORelation.constraint : <code>[Table](#Table)</code>
Foreign key [constraint](#Constraint) between [source table](#M2ORelation+sourceTable) and [target table](#M2ORelation+targetTable).

**Kind**: instance property of <code>[M2ORelation](#M2ORelation)</code>  
**Read only**: true  
**Example**  
```js
let relation     = product.M2ORelationRelations[0];  // RELATION:    line_item >---- product
let constraint   = relation.constraint;              // CONSTRAINT:               ^-- product_has_carts
let FKColumn     = relation.constraint.columns[0];   // COLUMN:      product_id (from line_item table)
```
<a name="O2MRelation"></a>
## O2MRelation ⇐ <code>[Relation](#Relation)</code>
**Kind**: global class  
**Extends:** <code>[Relation](#Relation)</code>  

* [O2MRelation](#O2MRelation) ⇐ <code>[Relation](#Relation)</code>
  * [new O2MRelation()](#new_O2MRelation_new)
  * [.type](#O2MRelation+type) : <code>relationType</code>
  * [.sourceTable](#O2MRelation+sourceTable) : <code>[Table](#Table)</code>
  * [.targetTable](#O2MRelation+targetTable) : <code>[Table](#Table)</code>
  * [.constraint](#O2MRelation+constraint) : <code>[Table](#Table)</code>

<a name="new_O2MRelation_new"></a>
### new O2MRelation()
Class which represent many to one relationship which resembles `hasMany` relation in ORMs (Object Relational Mappers).
Provides attributes and methods for details of the relationship.

<span id="exampleSchema"></span>Below is a database schema as an example:
```
size -------------------
id (PK)                |  ---------------------------< line_item >------------ cart
name                   |  |                            product_id (PFK)        id (PK)
                       |  |                            cart_id    (PFK)        name
                       ^  |
color -------------< product >------------- vendor
id (PK)              id        (PK)         id (PK)
name                 name                   name
                     color_id  (FK)
                     size_id   (FK)
                     vendor_id (FK)

```
Below is the same schema as image:
![Database Schema](../../images/schema-through.png)

Some definitions used in descriptions for [O2MRelation](#O2MRelation).
* ** Source Table: ** Table which this relationship belongs to.
* ** Target Table: ** Table that is related to base table.

**Example**  
```js
// Example tables have single primary key and examples first relation. So zero index ([0]) is used. Use all array elements if necessary.
// product ----< line_item
// (source)       (target)

let relation         = product.o2mRelations[0];              // RELATION:    product ---< line_item
let constraint       = relation.constraint;                  // CONSTRAINT:           ^-- product_has_carts
let sourceTable      = relation.sourceTable;                 // TABLE:       product
let targetTable      = relation.targetTable;                 // TABLE:       line_item
let FKColumn         = relation.constraint.columns[0];       // COLUMN:      product_id  (from line_item table)
let sourcePKColumn   = relation.sourceTable.primaryKeys[0];  // COLUMN:      id          (from product table)
```
<a name="O2MRelation+type"></a>
### o2MRelation.type : <code>relationType</code>
Type of relation. One of `ONE TO MANY` or `MANY TO MANY`.

**Kind**: instance property of <code>[O2MRelation](#O2MRelation)</code>  
**Read only**: true  
<a name="O2MRelation+sourceTable"></a>
### o2MRelation.sourceTable : <code>[Table](#Table)</code>
[Table](#Table) which this relation belongs to.

**Kind**: instance property of <code>[O2MRelation](#O2MRelation)</code>  
**Read only**: true  
**Example**  
```js
let relation     = product.O2MRelationRelations[0];  // RELATION:    product ---< line_item
let sourceTable  = relation.sourceTable;             // TABLE:       product
```
<a name="O2MRelation+targetTable"></a>
### o2MRelation.targetTable : <code>[Table](#Table)</code>
[Table](#Table) which this relation is referring to.

**Kind**: instance property of <code>[O2MRelation](#O2MRelation)</code>  
**Read only**: true  
**Example**  
```js
let relation     = product.O2MRelationRelations[0];  // RELATION:    product ---< line_item
let targetTable  = relation.targetTable;             // TABLE:       line_item
```
<a name="O2MRelation+constraint"></a>
### o2MRelation.constraint : <code>[Table](#Table)</code>
Foreign key [constraint](#Constraint) between [source table](#O2MRelation+sourceTable) and [target table](#O2MRelation+targetTable).

**Kind**: instance property of <code>[O2MRelation](#O2MRelation)</code>  
**Read only**: true  
**Example**  
```js
let relation     = product.O2MRelationRelations[0];  // RELATION:    product ---< line_item
let constraint   = relation.constraint;              // CONSTRAINT:           ^-- product_has_carts
let FKColumn     = relation.constraint.columns[0];   // COLUMN:      product_id (from line_item table)
```
<a name="Relation"></a>
## Relation
Base class for relations. Not used directly. See child classes.

**Kind**: global class  
**See**

- [O2MRelation](#O2MRelation) for one to many relationships.
- [M2MRelation](#M2MRelation) for many to many relationships.
- [M2ORelation](#M2ORelation) for many to one relationships.

<a name="new_Relation_new"></a>
### new Relation(args)

| Param | Type | Description |
| --- | --- | --- |
| args | <code>Object</code> | Referential constraint arguments. |
| args.registry | <code>Loki</code> | Loki.js database object. |
| args.attributes | <code>Object</code> | Attributes of the [Relation](#Relation) instance. |

<a name="Schema"></a>
## Schema
Class which represent a PostgreSQL schema. Provides attributes and methods for details of the database.

**Kind**: global class  

* [Schema](#Schema)
  * [new Schema(args)](#new_Schema_new)
  * [.name](#Schema+name) : <code>string</code>
  * [.fullName](#Schema+fullName) : <code>string</code>
  * [.fullCatalogName](#Schema+fullCatalogName) : <code>string</code>
  * [.db](#Schema+db) : <code>[DB](#DB)</code>
  * [.parent](#Schema+parent) : <code>[DB](#DB)</code>
  * [.tables](#Schema+tables) : <code>[Array.&lt;Table&gt;](#Table)</code> &#124; <code>null</code>
  * [.getTable(key)](#Schema+getTable) ⇒ <code>[Table](#Table)</code> &#124; <code>undefined</code>
  * [.tableExists(name)](#Schema+tableExists) ⇒ <code>boolean</code>
  * [.get(path)](#Schema+get) ⇒ <code>[Table](#Table)</code> &#124; <code>[Column](#Column)</code> &#124; <code>undefined</code>
  * [.getTables([callback])](#Schema+getTables) ⇒ <code>[Array.&lt;Table&gt;](#Table)</code> &#124; <code>undefined</code> &#124; <code>null</code>

<a name="new_Schema_new"></a>
### new Schema(args)

| Param | Type | Description |
| --- | --- | --- |
| args | <code>Object</code> | Database arguments. |
| args.registry | <code>Loki</code> | Loki.js object to get database details. |
| args.attributes | <code>Object</code> | Attributes of the [Schema](#Schema) instance. |

<a name="Schema+name"></a>
### schema.name : <code>string</code>
Name of the schema.

**Kind**: instance property of <code>[Schema](#Schema)</code>  
**Read only**: true  
<a name="Schema+fullName"></a>
### schema.fullName : <code>string</code>
Full name of the [Schema](#Schema) with (.) notation.

**Kind**: instance property of <code>[Schema](#Schema)</code>  
**Read only**: true  
**Example**  
```js
var fullName = schema.fullName; // crm.public
```
<a name="Schema+fullCatalogName"></a>
### schema.fullCatalogName : <code>string</code>
Full name of the [Schema](#Schema) with (.) notation including catalog name.

**Kind**: instance property of <code>[Schema](#Schema)</code>  
**Read only**: true  
**Example**  
```js
var fullCatalogName = schema.fullCatalogName; // crm.public
```
<a name="Schema+db"></a>
### schema.db : <code>[DB](#DB)</code>
[DB](#DB) this schema belongs to.

**Kind**: instance property of <code>[Schema](#Schema)</code>  
**Read only**: true  
**See**: Aliases [parent](#Schema+parent)  
**Example**  
```js
var db = schema.db; // DB instance
```
<a name="Schema+parent"></a>
### schema.parent : <code>[DB](#DB)</code>
[DB](#DB) this schema belongs to.

**Kind**: instance property of <code>[Schema](#Schema)</code>  
**Read only**: true  
**See**: Aliases [db](#Schema+db)  
**Example**  
```js
var db = schema.parent; // DB instance
```
<a name="Schema+tables"></a>
### schema.tables : <code>[Array.&lt;Table&gt;](#Table)</code> &#124; <code>null</code>
All [Table](#Table) instances in the database as an array. They are ordered by same order they are added.

**Kind**: instance property of <code>[Schema](#Schema)</code>  
**Read only**: true  
**Example**  
```js
var tables = schema.tables;
var name   = tables[0].name;
```
<a name="Schema+getTable"></a>
### schema.getTable(key) ⇒ <code>[Table](#Table)</code> &#124; <code>undefined</code>
Returns [Table](#Table) instance with given name or order.

**Kind**: instance method of <code>[Schema](#Schema)</code>  
**Returns**: <code>[Table](#Table)</code> &#124; <code>undefined</code> - - Requested [Table](#Table) instance.  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>string</code> &#124; <code>number</code> | Name or order number of the table. |

**Example**  
```js
var table = schema.getTable('account');
```
<a name="Schema+tableExists"></a>
### schema.tableExists(name) ⇒ <code>boolean</code>
Returns true if [Table](#Table) instance with given name or order number exists.

**Kind**: instance method of <code>[Schema](#Schema)</code>  
**Returns**: <code>boolean</code> - - `true` if table exists in schema, otherwise `false`  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> &#124; <code>number</code> | Name or order number of the table. |

**Example**  
```js
var accountExists = db.TableExists('account'); // true
var cakeExists    = db.TableExists('cake');  // false
```
<a name="Schema+get"></a>
### schema.get(path) ⇒ <code>[Table](#Table)</code> &#124; <code>[Column](#Column)</code> &#124; <code>undefined</code>
Returns [Table](#Table) or [Column](#Column) on given path relative to [Schema](#Schema). Path should be in dot (.) notation.

**Kind**: instance method of <code>[Schema](#Schema)</code>  
**Returns**: <code>[Table](#Table)</code> &#124; <code>[Column](#Column)</code> &#124; <code>undefined</code> - - Requested item.  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>string</code> | Path of the requested item in dot (.) notation such as 'public.contact' |

**Example**  
```js
var table  = db.get('contact'),      // Returns contact table in public schema.
    column = db.get('contact.name'); // Returns name column of the contact table.
```
<a name="Schema+getTables"></a>
### schema.getTables([callback]) ⇒ <code>[Array.&lt;Table&gt;](#Table)</code> &#124; <code>undefined</code> &#124; <code>null</code>
Retrieves all tables in the schema and executes given callback, if provided. Callback has a signature of
([Table](#Table), index, collection). If no callback is provided, returns an array of all [tables](#Table).

**Kind**: instance method of <code>[Schema](#Schema)</code>  

| Param | Type | Description |
| --- | --- | --- |
| [callback] | <code>[orderedTableCallback](#orderedTableCallback)</code> | Callback to be executed for each table. |

**Example**  
```js
db.getTables(function(table, i, collection) {
    var name = table.name;
    var ord  = i;
);
```
<a name="Table"></a>
## Table
Class which represent a table. Provides attributes and methods for details of the table. Tables have relationships
with other tables.

<span id="exampleSchema"></span>Below is a database schema which is used in code examples.
```
size -------------------
id (PK)                |  ---------------------------< line_item >------------ cart
name                   |  |                            product_id (PFK)        id (PK)
                       |  |                            cart_id    (PFK)        name
                       ^  |
color -------------< product >------------- vendor
id (PK)              id        (PK)         id (PK)
name                 name                   name
                     color_id  (FK)
                     size_id   (FK)
                     vendor_id (FK)
```
Below is the same schema as image:
![Database Schema](../../images/schema-through.png)

**Kind**: global class  

* [Table](#Table)
  * [new Table(args)](#new_Table_new)
  * [.name](#Table+name) : <code>string</code>
  * [.fullName](#Table+fullName) : <code>string</code>
  * [.fullCatalogName](#Table+fullCatalogName) : <code>string</code>
  * [.schema](#Table+schema) : <code>[Schema](#Schema)</code>
  * [.parent](#Table+parent) : <code>[Schema](#Schema)</code>
  * [.columns](#Table+columns) : <code>[Array.&lt;Column&gt;](#Column)</code> &#124; <code>null</code>
  * [.columnsByName](#Table+columnsByName) : <code>Object.&lt;string, Column&gt;</code> &#124; <code>null</code>
  * [.constraints](#Table+constraints) : <code>[Array.&lt;Constraint&gt;](#Constraint)</code> &#124; <code>null</code>
  * [.constraintsByName](#Table+constraintsByName) : <code>Object.&lt;string, Constraint&gt;</code> &#124; <code>null</code>
  * [.db](#Table+db) : <code>[DB](#DB)</code>
  * [.foreignKeyConstraints](#Table+foreignKeyConstraints) : <code>[Array.&lt;Constraint&gt;](#Constraint)</code> &#124; <code>null</code>
  * [.foreignKeyConstraintsByName](#Table+foreignKeyConstraintsByName) : <code>Object.&lt;string, Constraint&gt;</code> &#124; <code>null</code>
  * [.foreignKeyColumns](#Table+foreignKeyColumns) : <code>[Array.&lt;Column&gt;](#Column)</code> &#124; <code>null</code>
  * [.foreignKeyColumnsByName](#Table+foreignKeyColumnsByName) : <code>Object.&lt;string, Column&gt;</code> &#124; <code>null</code>
  * [.primaryKeyConstraint](#Table+primaryKeyConstraint) : <code>[Constraint](#Constraint)</code> &#124; <code>undefined</code>
  * [.primaryKeyColumns](#Table+primaryKeyColumns) : <code>[Array.&lt;Column&gt;](#Column)</code> &#124; <code>null</code>
  * [.primaryKeyColumnsByName](#Table+primaryKeyColumnsByName) : <code>Object.&lt;string, Column&gt;</code> &#124; <code>null</code>
  * [.hasManyTables](#Table+hasManyTables) : <code>[Array.&lt;Table&gt;](#Table)</code> &#124; <code>null</code>
  * [.hasManyTablesByName](#Table+hasManyTablesByName) : <code>Object.&lt;string, Table&gt;</code> &#124; <code>null</code>
  * [.hasManyTablesByFullName](#Table+hasManyTablesByFullName) : <code>Object.&lt;string, Table&gt;</code> &#124; <code>null</code>
  * [.belongsToTables](#Table+belongsToTables) : <code>[Array.&lt;Table&gt;](#Table)</code> &#124; <code>null</code>
  * [.belongsToTablesByName](#Table+belongsToTablesByName) : <code>Object.&lt;string, Table&gt;</code> &#124; <code>null</code>
  * [.belongsToTablesByFullName](#Table+belongsToTablesByFullName) : <code>Object.&lt;string, Table&gt;</code> &#124; <code>null</code>
  * [.belongsToManyTables](#Table+belongsToManyTables) : <code>[Array.&lt;Table&gt;](#Table)</code> &#124; <code>null</code>
  * [.belongsToManyTablesByName](#Table+belongsToManyTablesByName) : <code>Object.&lt;string, Table&gt;</code> &#124; <code>null</code>
  * [.belongsToManyTablesByFullName](#Table+belongsToManyTablesByFullName) : <code>Object.&lt;string, Table&gt;</code> &#124; <code>null</code>
  * [.m2mRelations](#Table+m2mRelations) : <code>[Array.&lt;M2MRelation&gt;](#M2MRelation)</code> &#124; <code>null</code>
  * [.o2mRelations](#Table+o2mRelations) : <code>[Array.&lt;O2MRelation&gt;](#O2MRelation)</code> &#124; <code>null</code>
  * [.m2oRelations](#Table+m2oRelations) : <code>[Array.&lt;M2ORelation&gt;](#M2ORelation)</code> &#124; <code>null</code>
  * [.getColumn(key)](#Table+getColumn) ⇒ <code>[Column](#Column)</code> &#124; <code>undefined</code>
  * [.columnExists(name)](#Table+columnExists) ⇒ <code>boolean</code>
  * [.get(path)](#Table+get) ⇒ <code>[Column](#Column)</code> &#124; <code>undefined</code>
  * [.getColumns([callback])](#Table+getColumns) ⇒ <code>[Array.&lt;Column&gt;](#Column)</code> &#124; <code>undefined</code> &#124; <code>null</code>
  * [.getConstraints([callback])](#Table+getConstraints) ⇒ <code>[Array.&lt;Constraint&gt;](#Constraint)</code> &#124; <code>undefined</code> &#124; <code>null</code>
  * [.getForeignKeyConstraints([callback])](#Table+getForeignKeyConstraints) ⇒ <code>[Array.&lt;Constraint&gt;](#Constraint)</code> &#124; <code>undefined</code> &#124; <code>null</code>
  * [.getForeignKeyColumns([callback])](#Table+getForeignKeyColumns) ⇒ <code>[Array.&lt;Column&gt;](#Column)</code> &#124; <code>undefined</code> &#124; <code>null</code>
  * [.getPrimaryKeyColumns([callback])](#Table+getPrimaryKeyColumns) ⇒ <code>[Array.&lt;Column&gt;](#Column)</code> &#124; <code>undefined</code> &#124; <code>null</code>
  * [.getPrimaryKeyConstraint([callback])](#Table+getPrimaryKeyConstraint) ⇒ <code>[Array.&lt;Constraint&gt;](#Constraint)</code> &#124; <code>undefined</code> &#124; <code>null</code>
  * [.getHasManyTables([callback])](#Table+getHasManyTables) ⇒ <code>[Array.&lt;Column&gt;](#Column)</code> &#124; <code>undefined</code> &#124; <code>null</code>
  * [.getBelongsToTables([callback])](#Table+getBelongsToTables) ⇒ <code>[Array.&lt;Column&gt;](#Column)</code> &#124; <code>undefined</code> &#124; <code>null</code>
  * [.getBelongsToManyTables([callback])](#Table+getBelongsToManyTables) ⇒ <code>[Array.&lt;Column&gt;](#Column)</code> &#124; <code>undefined</code> &#124; <code>null</code>
  * [.getM2MRelations([callback])](#Table+getM2MRelations) ⇒ <code>[Array.&lt;M2MRelation&gt;](#M2MRelation)</code> &#124; <code>undefined</code> &#124; <code>null</code>
  * [.getO2MRelations([callback])](#Table+getO2MRelations) ⇒ <code>[Array.&lt;O2MRelation&gt;](#O2MRelation)</code> &#124; <code>undefined</code> &#124; <code>null</code>
  * [.getM2ORelations([callback])](#Table+getM2ORelations) ⇒ <code>[Array.&lt;M2ORelation&gt;](#M2ORelation)</code> &#124; <code>undefined</code> &#124; <code>null</code>

<a name="new_Table_new"></a>
### new Table(args)

| Param | Type | Description |
| --- | --- | --- |
| args | <code>Object</code> | Database arguments. |
| args.registry | <code>Loki</code> | Loki.js database object. |
| args.attributes | <code>Object</code> | Attributes of the [Table](#Table) instance. |

<a name="Table+name"></a>
### table.name : <code>string</code>
Name of the table.

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
<a name="Table+fullName"></a>
### table.fullName : <code>string</code>
Full name of the [Table](#Table) with (.) notation.

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
**Example**  
```js
var fullName = table.fullName; // public.account
```
<a name="Table+fullCatalogName"></a>
### table.fullCatalogName : <code>string</code>
Full name of the [Table](#Table) with (.) notation including catalog name.

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
**Example**  
```js
var fullName = table.fullName; // crm.public.account
```
<a name="Table+schema"></a>
### table.schema : <code>[Schema](#Schema)</code>
[Schema](#Schema) this table belongs to.

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
**See**: Aliases [parent](#Table+parent)  
**Example**  
```js
var schema = table.schema; // Schema instance
```
<a name="Table+parent"></a>
### table.parent : <code>[Schema](#Schema)</code>
[Schema](#Schema) this table belongs to.

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
**See**: Aliases [schema](#Table+schema)  
**Example**  
```js
var schema = table.parent; // Schema instance
```
<a name="Table+columns"></a>
### table.columns : <code>[Array.&lt;Column&gt;](#Column)</code> &#124; <code>null</code>
All [Column](#Column) instances in the table as an array. They are ordered by same order they are added.

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
**Example**  
```js
var columns = table.columns;
var name    = columns[0].name;
```
<a name="Table+columnsByName"></a>
### table.columnsByName : <code>Object.&lt;string, Column&gt;</code> &#124; <code>null</code>
All [Column](#Column) instances in the table as a simple object. Keys are column names, values are [Column](#Column) instances.

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
**Example**  
```js
var columns   = table.columnsByName;
var ageColumn = columns.age;
```
<a name="Table+constraints"></a>
### table.constraints : <code>[Array.&lt;Constraint&gt;](#Constraint)</code> &#124; <code>null</code>
All [Constraint](#Constraint) instances in the table as an array. They are ordered by same order they are added.

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
<a name="Table+constraintsByName"></a>
### table.constraintsByName : <code>Object.&lt;string, Constraint&gt;</code> &#124; <code>null</code>
All [Constraint](#Constraint) instances in the table as a simple object. Keys are constraint names, values are [Constraint](#Constraint) instances.

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
<a name="Table+db"></a>
### table.db : <code>[DB](#DB)</code>
[DB](#DB) this table belongs to.

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
<a name="Table+foreignKeyConstraints"></a>
### table.foreignKeyConstraints : <code>[Array.&lt;Constraint&gt;](#Constraint)</code> &#124; <code>null</code>
All [Constraint](#Constraint) instances which are foreign key constraints in the table as an array.
They are ordered by same order they are defined in database.

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
**See**: [o2mRelations](#Table+o2mRelations), [m2oRelations](#Table+m2oRelations), [m2mRelations](#Table+m2mRelations) to get more details about [relations](#Relation).  
<a name="Table+foreignKeyConstraintsByName"></a>
### table.foreignKeyConstraintsByName : <code>Object.&lt;string, Constraint&gt;</code> &#124; <code>null</code>
All [Constraint](#Constraint) instances which are foreign key constraints in the table as a simple object.
Keys are constraint names, values are [Constraint](#Constraint) instances.

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
**See**: [o2mRelations](#Table+o2mRelations), [m2oRelations](#Table+m2oRelations), [m2mRelations](#Table+m2mRelations) to get more details about [relations](#Relation).  
<a name="Table+foreignKeyColumns"></a>
### table.foreignKeyColumns : <code>[Array.&lt;Column&gt;](#Column)</code> &#124; <code>null</code>
All foreign key [columns](#Column) of all [foreignKeyConstraints](#Table+foreignKeyConstraints).
Foreign key [constraints](#Constraint) may contain more than one column. To get foreign key columns of a specific foreign key constraint
use [foreignKeyConstraints](#Table+foreignKeyConstraints).[columns](#Constraint+columns)

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
<a name="Table+foreignKeyColumnsByName"></a>
### table.foreignKeyColumnsByName : <code>Object.&lt;string, Column&gt;</code> &#124; <code>null</code>
Object containing foreign key [columns](#Column) of this table. Keys are column names, values are
[columns](#Column) instances.
Foreign key [constraints](#Constraint) may contain more than one column. To get foreign key columns of a specific foreign key constraint
use [foreignKeyConstraints](#Table+foreignKeyConstraints).[columns](#Constraint+columns)

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
**Example**  
```js
let pkColumns  = table.foreignKeyColumnsByName;
```
<a name="Table+primaryKeyConstraint"></a>
### table.primaryKeyConstraint : <code>[Constraint](#Constraint)</code> &#124; <code>undefined</code>
Primary key [constraint](#Constraint) instance of this table.

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
**See**: [primaryKeyColumns](#Table+primaryKeyColumns) to get primary key columns directly.  
**Example**  
```js
let pkConstraint = table.primaryKeyConstraint;
let pkColumns  = pkConstraint.columns;
```
<a name="Table+primaryKeyColumns"></a>
### table.primaryKeyColumns : <code>[Array.&lt;Column&gt;](#Column)</code> &#124; <code>null</code>
Primary key [columns](#Column) of this table.

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
**See**: [primaryKeyConstraint](#Table+primaryKeyConstraint) to get primary key constraint.  
**Example**  
```js
let pkColumns  = table.primaryKeyColumns;
```
<a name="Table+primaryKeyColumnsByName"></a>
### table.primaryKeyColumnsByName : <code>Object.&lt;string, Column&gt;</code> &#124; <code>null</code>
Object containing primary key [columns](#Column) of this table. Keys are column names, values are
[columns](#Column) instances.

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
**See**: [primaryKeyConstraint](#Table+primaryKeyConstraint) to get primary key constraint.  
**Example**  
```js
let pkColumns  = table.primaryKeyColumnsByName;
```
<a name="Table+hasManyTables"></a>
### table.hasManyTables : <code>[Array.&lt;Table&gt;](#Table)</code> &#124; <code>null</code>
[Tables](#Table) which this table has relationship of type `one to many`.

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
**See**: [Example schema](#exampleSchema)  
**Example**  
```js
// Vendor (id) has many products (vendor_id)
let productTable = vendorTable.hasManyTables[0];
```
<a name="Table+hasManyTablesByName"></a>
### table.hasManyTablesByName : <code>Object.&lt;string, Table&gt;</code> &#124; <code>null</code>
Object of [Tables](#Table) which this table has relationship of type `one to many`. Object keys
are table names, object values are [Table](#Table) instances.
** CAVEAT: Two tables may have same name in different schemas**, such as `public.account` and `other_schema.account`.
This is not a problem if there is only one PostgreSQL schema i.e. public. Otherwise it is advised to be used
[hasManyTablesByFullName](#Table+hasManyTablesByFullName).

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
**See**

- [Example schema](#exampleSchema)
- [hasManyTablesByFullName](#Table+hasManyTablesByFullName)

**Example**  
```js
// Vendor (id) has many products (vendor_id)
let productTable = vendorTable.hasManyTablesByName.product;
```
<a name="Table+hasManyTablesByFullName"></a>
### table.hasManyTablesByFullName : <code>Object.&lt;string, Table&gt;</code> &#124; <code>null</code>
Object of [Tables](#Table) which this table has relationship of type `one to many`. Object keys
are table names including schema name (i.e. `public.account`), object values are [Table](#Table) instances.
** CAVEAT: Full table name contains a dot (.). You should access them with bracket notation. See example below.**
[hasManyTablesByName](#Table+hasManyTablesByName).

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
**See**

- [Example schema](#exampleSchema)
- [hasManyTablesByName](#Table+hasManyTablesByName)

**Example**  
```js
// Vendor (id) has many products (vendor_id)
let productTable = vendorTable.hasManyTablesByFullName['public.product'];
```
<a name="Table+belongsToTables"></a>
### table.belongsToTables : <code>[Array.&lt;Table&gt;](#Table)</code> &#124; <code>null</code>
[Tables](#Table) which this table has relationship of type `belongs to` which is reverse direction of `one to many`.

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
**See**: [Example schema](#exampleSchema)  
**Example**  
```js
// Vendor (id) has many products (vendor_id)
let vendorTable = productTable.belongsToTables[0];
```
<a name="Table+belongsToTablesByName"></a>
### table.belongsToTablesByName : <code>Object.&lt;string, Table&gt;</code> &#124; <code>null</code>
Object of [Tables](#Table) which this table has relationship of type `belongs to` which is reverse direction of `one to many`. Object keys
are table names, object values are [Table](#Table) instances.
** CAVEAT: Two tables may have same name in different schemas**, such as `public.account` and `other_schema.account`.
This is not a problem if there is only one PostgreSQL schema i.e. public. Otherwise it is advised to be used
[belongsToTablesByFullName](#Table+belongsToTablesByFullName).

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
**See**

- [Example schema](#exampleSchema)
- [belongsToTablesByFullName](#Table+belongsToTablesByFullName)

**Example**  
```js
// Vendor (id) has many products (vendor_id)
let vendorTable = productTable.belongsToTablesByName.product;
```
<a name="Table+belongsToTablesByFullName"></a>
### table.belongsToTablesByFullName : <code>Object.&lt;string, Table&gt;</code> &#124; <code>null</code>
Object of [Tables](#Table) which this table has relationship of type `belongs to` which is reverse direction of `one to many`. Object keys
are table names including schema name (i.e. `public.account`), object values are [Table](#Table) instances.
** CAVEAT: Full table name contains a dot (.). You should access them with bracket notation. See example below.**
[belongsToTablesByName](#Table+belongsToTablesByName).

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
**See**

- [Example schema](#exampleSchema)
- [belongsToTablesByName](#Table+belongsToTablesByName)

**Example**  
```js
// Vendor (id) has many products (vendor_id)
let vendorTable = productTable.belongsToTablesByFullName['public.product'];
```
<a name="Table+belongsToManyTables"></a>
### table.belongsToManyTables : <code>[Array.&lt;Table&gt;](#Table)</code> &#124; <code>null</code>
[Tables](#Table) which this table has relationship of type `many to many`.

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
**See**: [Example schema](#exampleSchema)  
**Example**  
```js
// Cart (id) has many products (id) through line_item join table.
let productTable = cartTable.belongsToManyTables[0];
```
<a name="Table+belongsToManyTablesByName"></a>
### table.belongsToManyTablesByName : <code>Object.&lt;string, Table&gt;</code> &#124; <code>null</code>
Object of [Tables](#Table) which this table has relationship of type `many to many`. Object keys
are table names, object values are [Table](#Table) instances.
** CAVEAT: Two tables may have same name in different schemas**, such as `public.account` and `other_schema.account`.
This is not a problem if there is only one PostgreSQL schema i.e. public. Otherwise it is advised to be used
[belongsToManyTablesByFullName](#Table+belongsToManyTablesByFullName).

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
**See**

- [Example schema](#exampleSchema)
- [belongsToManyTablesByFullName](#Table+belongsToManyTablesByFullName)

**Example**  
```js
// Cart (id) has many products (id) through line_item join table.
let productTable = cartTable.belongsToManyTablesByName.product;
```
<a name="Table+belongsToManyTablesByFullName"></a>
### table.belongsToManyTablesByFullName : <code>Object.&lt;string, Table&gt;</code> &#124; <code>null</code>
Object of [Tables](#Table) which this table has relationship of type `many to many`. Object keys
are table names including schema name (i.e. `public.account`), object values are [Table](#Table) instances.
** CAVEAT: Full table name contains a dot (.). You should access them with bracket notation. See example below.**
[belongsToManyTablesByName](#Table+belongsToManyTablesByName).

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
**See**

- [Example schema](#exampleSchema)
- [belongsToManyTablesByName](#Table+belongsToManyTablesByName)

**Example**  
```js
// Cart (id) has many products (id) through line_item join table.
let productTable = cartTable.belongsToManyTablesByName['public.product'];
```
<a name="Table+m2mRelations"></a>
### table.m2mRelations : <code>[Array.&lt;M2MRelation&gt;](#M2MRelation)</code> &#124; <code>null</code>
List of [many to many relationships](#M2MRelation) of the table. [M2MRelation](#M2MRelation) resembles
`has many through` and `belongs to many` relations in ORMs has some useful methods and information for generating ORM classes.

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
<a name="Table+o2mRelations"></a>
### table.o2mRelations : <code>[Array.&lt;O2MRelation&gt;](#O2MRelation)</code> &#124; <code>null</code>
List of [one to many relationships](#O2MRelation) of the table. [O2MRelation](#O2MRelation) resembles
`has many` relations in ORMs and has some useful methods and information for generating ORM classes.

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
<a name="Table+m2oRelations"></a>
### table.m2oRelations : <code>[Array.&lt;M2ORelation&gt;](#M2ORelation)</code> &#124; <code>null</code>
List of [many to one relationships](#M2ORelation) of the table. [M2ORelation](#M2ORelation) resembles
`belongs to` relations in ORMs and has some useful methods and information for generating ORM classes.

**Kind**: instance property of <code>[Table](#Table)</code>  
**Read only**: true  
<a name="Table+getColumn"></a>
### table.getColumn(key) ⇒ <code>[Column](#Column)</code> &#124; <code>undefined</code>
Returns [Column](#Column) instance with given name or order.

**Kind**: instance method of <code>[Table](#Table)</code>  
**Returns**: <code>[Column](#Column)</code> &#124; <code>undefined</code> - - Requested [Column](#Column) instance.  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>string</code> &#124; <code>number</code> | Name or order number of the column. |

**Example**  
```js
var column = table.getColumn('surname');
```
<a name="Table+columnExists"></a>
### table.columnExists(name) ⇒ <code>boolean</code>
Returns true if [Column](#Column) instance with given name or order number exists.

**Kind**: instance method of <code>[Table](#Table)</code>  
**Returns**: <code>boolean</code> - - `true` if schema column in table, otherwise `false`.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> &#124; <code>number</code> | Name or order number of the column. |

**Example**  
```js
var ageColumn  = db.schemaExists('age');  // true
var jokeColumn = db.schemaExists('joke'); // false
```
<a name="Table+get"></a>
### table.get(path) ⇒ <code>[Column](#Column)</code> &#124; <code>undefined</code>
Returns [Column](#Column) on given path relative to [Table](#Table).

**Kind**: instance method of <code>[Table](#Table)</code>  
**Returns**: <code>[Column](#Column)</code> &#124; <code>undefined</code> - - Requested item.  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>string</code> | Path of the requested item in dot (.) notation such as 'public.contact' |

**Example**  
```js
var column = table.get('contact'),      // Returns contact column in public table.
```
<a name="Table+getColumns"></a>
### table.getColumns([callback]) ⇒ <code>[Array.&lt;Column&gt;](#Column)</code> &#124; <code>undefined</code> &#124; <code>null</code>
Retrieves all columns in the table, executes given callback and returns null, if provided. Callback has a signature of
([Column](#Column), index, collection). If no callback is provided, returns an array of all [columns](#Column).

**Kind**: instance method of <code>[Table](#Table)</code>  

| Param | Type | Description |
| --- | --- | --- |
| [callback] | <code>[orderedColumnCallback](#orderedColumnCallback)</code> | Callback to be executed for each column. |

**Example**  
```js
schema.getColumns(function(column, i, collection) {
    var name = column.name;
    var ord  = i;
);
```
<a name="Table+getConstraints"></a>
### table.getConstraints([callback]) ⇒ <code>[Array.&lt;Constraint&gt;](#Constraint)</code> &#124; <code>undefined</code> &#124; <code>null</code>
Retrieves all constraints in the table, executes given callback and returns null, if provided. Callback has a signature of
([Constraint](#Constraint), index, collection). If no callback is provided, returns an array of all [constraints](#Constraint).

**Kind**: instance method of <code>[Table](#Table)</code>  
**See**: [getForeignKeyConstraints](#Table+getForeignKeyConstraints) to get only foreign key constraints.  

| Param | Type | Description |
| --- | --- | --- |
| [callback] | <code>[orderedConstraintCallback](#orderedConstraintCallback)</code> | Callback to be executed for each constraint. |

**Example**  
```js
table.getConstraints(function(constraint, i, collection) {
    var name = constraint.name;
    var ord  = i;
);
```
<a name="Table+getForeignKeyConstraints"></a>
### table.getForeignKeyConstraints([callback]) ⇒ <code>[Array.&lt;Constraint&gt;](#Constraint)</code> &#124; <code>undefined</code> &#124; <code>null</code>
Retrieves all [constraints](#Constraint) which are foreign key constraints in the table, executes given callback and returns null, if provided. Callback has a signature of
([Constraint](#Constraint), index, collection). If no callback is provided, returns an array of all [constraints](#Constraint).

**Kind**: instance method of <code>[Table](#Table)</code>  
**See**

- [getO2MRelations](#Table+getO2MRelations), [getM2MRelations](#Table+getM2MRelations) to get more details about [relations](#Relation).
- [getConstraints](#Table+getConstraints) to get all constraints.


| Param | Type | Description |
| --- | --- | --- |
| [callback] | <code>[orderedConstraintCallback](#orderedConstraintCallback)</code> | Callback to be executed for each constraint. |

**Example**  
```js
table.getConstraints(function(constraint, i, collection) {
    var name = constraint.name;
    var ord  = i;
);
```
<a name="Table+getForeignKeyColumns"></a>
### table.getForeignKeyColumns([callback]) ⇒ <code>[Array.&lt;Column&gt;](#Column)</code> &#124; <code>undefined</code> &#124; <code>null</code>
Retrieves all foreign key [columns](#Column) of all foreign key [constraints](#Constraint) in the table, executes given callback and returns null, if provided. Callback has a signature of
([Column](#Column), index, collection). If no callback is provided, returns an array of all [columns](#Column).

**Kind**: instance method of <code>[Table](#Table)</code>  

| Param | Type | Description |
| --- | --- | --- |
| [callback] | <code>[orderedColumnCallback](#orderedColumnCallback)</code> | Callback to be executed for each column. |

**Example**  
```js
table.getForeignKeyColumns(function(column, i, collection) {
    var name = column.name;
    var ord  = i;
);
```
<a name="Table+getPrimaryKeyColumns"></a>
### table.getPrimaryKeyColumns([callback]) ⇒ <code>[Array.&lt;Column&gt;](#Column)</code> &#124; <code>undefined</code> &#124; <code>null</code>
Retrieves all primary key [columns](#Column) in the table, executes given callback and returns null, if provided. Callback has a signature of
([Column](#Column), index, collection). If no callback is provided, returns an array of all [columns](#Column).

**Kind**: instance method of <code>[Table](#Table)</code>  

| Param | Type | Description |
| --- | --- | --- |
| [callback] | <code>[orderedColumnCallback](#orderedColumnCallback)</code> | Callback to be executed for each column. |

**Example**  
```js
table.getPrimaryKeyColumns(function(column, i, collection) {
    var name = column.name;
    var ord  = i;
);
```
<a name="Table+getPrimaryKeyConstraint"></a>
### table.getPrimaryKeyConstraint([callback]) ⇒ <code>[Array.&lt;Constraint&gt;](#Constraint)</code> &#124; <code>undefined</code> &#124; <code>null</code>
Retrieves [primary key constraint](#Constraint) of the table and executes given callback and returns null, if provided. Callback has a signature of
([Constraint](#Constraint), index, collection). If no callback is provided, returns single element array of [primary key constraint](#Constraint).

**Kind**: instance method of <code>[Table](#Table)</code>  

| Param | Type | Description |
| --- | --- | --- |
| [callback] | <code>[orderedConstraintCallback](#orderedConstraintCallback)</code> | Callback to be executed for single constraint. |

**Example**  
```js
table.getPrimaryKeyConstraint(function(constraint, i, collection) {
    var name = constraint.name;
    var ord  = i;
);
```
<a name="Table+getHasManyTables"></a>
### table.getHasManyTables([callback]) ⇒ <code>[Array.&lt;Column&gt;](#Column)</code> &#124; <code>undefined</code> &#124; <code>null</code>
Retrieves all [tables](#Table) which this table has relationship of type `one to many`, executes given callback and returns null if provided.
Callback has a signature of ([Table](#Table), index, collection). If no callback is provided, returns an array of all [tables](#Table).

**Kind**: instance method of <code>[Table](#Table)</code>  

| Param | Type | Description |
| --- | --- | --- |
| [callback] | <code>[orderedTableCallback](#orderedTableCallback)</code> | Callback to be executed for each [table](#Table). |

<a name="Table+getBelongsToTables"></a>
### table.getBelongsToTables([callback]) ⇒ <code>[Array.&lt;Column&gt;](#Column)</code> &#124; <code>undefined</code> &#124; <code>null</code>
Retrieves all [tables](#Table) which this table has relationship of type `one to many` which is reverse direction of `one to many`, executes given callback and returns null if provided.
Callback has a signature of ([Table](#Table), index, collection). If no callback is provided, returns an array of all [tables](#Table).

**Kind**: instance method of <code>[Table](#Table)</code>  

| Param | Type | Description |
| --- | --- | --- |
| [callback] | <code>[orderedTableCallback](#orderedTableCallback)</code> | Callback to be executed for each [table](#Table). |

<a name="Table+getBelongsToManyTables"></a>
### table.getBelongsToManyTables([callback]) ⇒ <code>[Array.&lt;Column&gt;](#Column)</code> &#124; <code>undefined</code> &#124; <code>null</code>
Retrieves all [tables](#Table) which this table has relationship of type `many to many`, executes given callback and returns null if provided.
Callback has a signature of ([Table](#Table), index, collection). If no callback is provided, returns an array of all [tables](#Table).

**Kind**: instance method of <code>[Table](#Table)</code>  

| Param | Type | Description |
| --- | --- | --- |
| [callback] | <code>[orderedTableCallback](#orderedTableCallback)</code> | Callback to be executed for each [table](#Table). |

<a name="Table+getM2MRelations"></a>
### table.getM2MRelations([callback]) ⇒ <code>[Array.&lt;M2MRelation&gt;](#M2MRelation)</code> &#124; <code>undefined</code> &#124; <code>null</code>
List of [many to many relationships](#M2MRelation) of the table. [M2MRelation](#M2MRelation) resembles
`has many through` and `belongs to many` relations in ORMs has some useful methods and information for generating ORM classes.

**Kind**: instance method of <code>[Table](#Table)</code>  

| Param | Type | Description |
| --- | --- | --- |
| [callback] | <code>[orderedRelationCallback](#orderedRelationCallback)</code> | Callback to be executed for each [many to many relation](#M2MRelation). |

<a name="Table+getO2MRelations"></a>
### table.getO2MRelations([callback]) ⇒ <code>[Array.&lt;O2MRelation&gt;](#O2MRelation)</code> &#124; <code>undefined</code> &#124; <code>null</code>
List of [one to many relationships](#O2MRelation) of the table. [O2MRelation](#O2MRelation) resembles
`has many` relations in ORMs and has some useful methods and information for generating ORM classes.

**Kind**: instance method of <code>[Table](#Table)</code>  

| Param | Type | Description |
| --- | --- | --- |
| [callback] | <code>[orderedRelationCallback](#orderedRelationCallback)</code> | Callback to be executed for each [one to many relation](#O2MRelation). |

<a name="Table+getM2ORelations"></a>
### table.getM2ORelations([callback]) ⇒ <code>[Array.&lt;M2ORelation&gt;](#M2ORelation)</code> &#124; <code>undefined</code> &#124; <code>null</code>
List of [many to one relationships](#M2ORelation) of the table. [M2ORelation](#M2ORelation) resembles
`belongs to` relations in ORMs and has some useful methods and information for generating ORM classes.

**Kind**: instance method of <code>[Table](#Table)</code>  

| Param | Type | Description |
| --- | --- | --- |
| [callback] | <code>[orderedRelationCallback](#orderedRelationCallback)</code> | Callback to be executed for each [many to one relation](#M2ORelation). |

<a name="postgreSQLDataType"></a>
## postgreSQLDataType : <code>enum</code>
PostgreSQL data types as returned by [type](#Column+type), [Column#data_type](Column#data_type), [Column#udType](Column#udType)
[userDefinedType](#Column+userDefinedType) and [Column#udt_name](Column#udt_name).

**Kind**: global enum  
**Read only**: true  
**Properties**

| Name | Type | Default |
| --- | --- | --- |
| array | <code>string</code> | <code>&quot;array&quot;</code> | 
| bigint | <code>string</code> | <code>&quot;bigint&quot;</code> | 
| bigserial | <code>string</code> | <code>&quot;bigserial&quot;</code> | 
| bit | <code>string</code> | <code>&quot;bit&quot;</code> | 
| &quot;bit varying&quot; | <code>string</code> | <code>&quot;bit varying&quot;</code> | 
| boolean | <code>string</code> | <code>&quot;boolean&quot;</code> | 
| box | <code>string</code> | <code>&quot;box&quot;</code> | 
| bytea | <code>string</code> | <code>&quot;bytea&quot;</code> | 
| character | <code>string</code> | <code>&quot;character&quot;</code> | 
| &quot;character varying&quot; | <code>string</code> | <code>&quot;character varying&quot;</code> | 
| cidr | <code>string</code> | <code>&quot;cidr&quot;</code> | 
| circle | <code>string</code> | <code>&quot;circle&quot;</code> | 
| date | <code>string</code> | <code>&quot;date&quot;</code> | 
| &quot;double precision&quot; | <code>string</code> | <code>&quot;double precision&quot;</code> | 
| hstore | <code>string</code> | <code>&quot;hstore&quot;</code> | 
| inet | <code>string</code> | <code>&quot;inet&quot;</code> | 
| integer | <code>string</code> | <code>&quot;integer&quot;</code> | 
| interval | <code>string</code> | <code>&quot;interval&quot;</code> | 
| json | <code>string</code> | <code>&quot;json&quot;</code> | 
| jsonb | <code>string</code> | <code>&quot;jsonb&quot;</code> | 
| line | <code>string</code> | <code>&quot;line&quot;</code> | 
| lseg | <code>string</code> | <code>&quot;lseg&quot;</code> | 
| macaddr | <code>string</code> | <code>&quot;macaddr&quot;</code> | 
| money | <code>string</code> | <code>&quot;money&quot;</code> | 
| numeric | <code>string</code> | <code>&quot;numeric&quot;</code> | 
| path | <code>string</code> | <code>&quot;path&quot;</code> | 
| point | <code>string</code> | <code>&quot;point&quot;</code> | 
| polygon | <code>string</code> | <code>&quot;polygon&quot;</code> | 
| real | <code>string</code> | <code>&quot;real&quot;</code> | 
| smallint | <code>string</code> | <code>&quot;smallint&quot;</code> | 
| smallserial | <code>string</code> | <code>&quot;smallserial&quot;</code> | 
| serial | <code>string</code> | <code>&quot;serial&quot;</code> | 
| text | <code>string</code> | <code>&quot;text&quot;</code> | 
| &quot;time without time zone&quot; | <code>string</code> | <code>&quot;time without time zone&quot;</code> | 
| &quot;time with time zone&quot; | <code>string</code> | <code>&quot;time with time zone&quot;</code> | 
| &quot;timestamp without time zone&quot; | <code>string</code> | <code>&quot;timestamp without time zone&quot;</code> | 
| &quot;timestamp with time zone&quot; | <code>string</code> | <code>&quot;timestamp with time zone&quot;</code> | 
| tsquery | <code>string</code> | <code>&quot;tsquery&quot;</code> | 
| tsvector | <code>string</code> | <code>&quot;tsvector&quot;</code> | 
| txid_snapshot | <code>string</code> | <code>&quot;txid_snapshot&quot;</code> | 
| uuid | <code>string</code> | <code>&quot;uuid&quot;</code> | 
| xml | <code>string</code> | <code>&quot;xml&quot;</code> | 

<a name="constraintRule"></a>
## constraintRule : <code>enum</code>
Referential constraint rules.

**Kind**: global enum  
**Read only**: true  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| CASCADE | <code>string</code> | <code>&quot;CASCADE&quot;</code> | Specifies that when a referenced row is deleted, row(s) referencing it should be automatically deleted as well. |
| &quot;SET NULL&quot; | <code>string</code> | <code>&quot;SET NULL&quot;</code> | These cause the referencing column(s) in the referencing row(s) to be set to nulls, respectively, when the referenced row is deleted. |
| &quot;SET DEFAULT&quot; | <code>string</code> | <code>&quot;SET DEFAULT&quot;</code> | These cause the referencing column(s) in the referencing row(s) to be set to default values, respectively, when the referenced row is deleted. |
| RESTRICT | <code>string</code> | <code>&quot;RESTRICT&quot;</code> | Prevents deletion of a referenced row |
| &quot;NO ACTION&quot; | <code>string</code> | <code>&quot;NO ACTION&quot;</code> | Means that if any referencing rows still exist when the constraint is checked, an error is raised; |

<a name="orderedSchemaCallback"></a>
## orderedSchemaCallback : <code>function</code>
Callback function to execute for each [Schema](#Schema) in an ordered collection.

**Kind**: global typedef  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>[Schema](#Schema)</code> | [Schema](#Schema) from related collection. |
| index | <code>number</code> | Index of the [Schema](#Schema). |
| collection | <code>[Array.&lt;Schema&gt;](#Schema)</code> | Whole collection array. |

<a name="orderedTableCallback"></a>
## orderedTableCallback : <code>function</code>
Callback function to execute for each [Table](#Table) in an ordered collection.

**Kind**: global typedef  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>[Table](#Table)</code> | [Table](#Table) from related collection. |
| index | <code>number</code> | Index of the [Table](#Table). |
| collection | <code>[Array.&lt;Table&gt;](#Table)</code> | Whole collection array. |

<a name="orderedColumnCallback"></a>
## orderedColumnCallback : <code>function</code>
Callback function to execute for each [Column](#Column) in an ordered collection.

**Kind**: global typedef  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>[Column](#Column)</code> | [Column](#Column) from related collection. |
| index | <code>number</code> | Index of the [Column](#Column). |
| collection | <code>[Array.&lt;Column&gt;](#Column)</code> | Whole collection array. |

<a name="orderedConstraintCallback"></a>
## orderedConstraintCallback : <code>function</code>
Callback function to execute for each [Constraint](#Constraint) in an ordered collection.

**Kind**: global typedef  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>[Constraint](#Constraint)</code> | [Constraint](#Constraint) from related collection. |
| index | <code>number</code> | Index of the [Constraint](#Constraint). |
| collection | <code>[Array.&lt;Constraint&gt;](#Constraint)</code> | Whole collection array. |

<a name="orderedRelationCallback"></a>
## orderedRelationCallback : <code>function</code>
Callback function to execute for each [Relation](#Relation) in an ordered collection.

**Kind**: global typedef  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>[Relation](#Relation)</code> | [Relation](#Relation) from related collection. |
| index | <code>number</code> | Index of the [Relation](#Relation). |
| collection | <code>[Array.&lt;Constraint&gt;](#Constraint)</code> | Whole collection array. |

<div id="History"></div>

**Note**: Version history for minimal documentation updates are not listed here to prevent cluttering.

### Why v2 has incompatible changes?
Version 2 is designed to be more elegant and more intuitive. Methods are changed to read only attributes and new methods
 are easily distinguished from attributes with verb based names such as `columns` vs `getColumns()`.

Additionally new `Relation` classes are added. Some of the features are moved from `Constraint` to `Relation`,
 because some features are technically not available in DB Engine and those features misrepresent `Constraint`.
 
For example many to many relations are virtual relationships which do not actually exist in database. They are
tables joined via a third join table.

# History & Release Notes

###### 2.0.0-alpha.1  / 2015-11-11
* ** BREAKING CHANGES **
* Completely rewritten.
* Methods are converted to read only attributes.
* New methods are named as verb such as getColumn().
* New classes added: Relation, O2MRelation (one to many), M2ORelation (many to one), M2M Relation (many to many).
* Constraint features that are technically not available in DB Engine moved from `Constraint` class to related `Relation` classes.
* Documentation updated completely and added clearer examples.
* Some method names and attributes are more intuitive than previous version.

###### 1.11.1 / 2015-06-16
* Added: JSONB support. Contributed by: viniciuspinto (https://github.com/viniciuspinto)

###### 1.11.0 / 2014-12-30
* Added: Constraint.throughForeignKeyConstraintToSelf() method added.
* Added: Winston logging.
* Fixed: Many to Many relations has name collisions if join table connects more than one table and one of the tables has more than one connection to join table. Naming of many to many relations changed.

###### 1.10.0 / 2014-12-23
* Added: db.includedSchemas method to get list of requested schemas to be parsed.
* Added: db.schemaIncluded method to determine if given schema name is one of the requested schemas to be parsed.
* Fix: If a table has a reference to not included schema, throws exception. Should not include its foreign key.
* Doc update.

###### 1.9.0 / 2014-12-12
* Added: table.hasManyThrough.throughForeignKeyConstraint method added to constraint class.

###### 1.8.3 / 2014-12-10
* Fix: Sequelize type length, precision.

###### 1.8.2 / 2014-12-10
* Fix: Sequelize type date, time etc. has no length property.
* Fix: Sequelize type dateonly added.
* Tests added.

###### 1.8.0 / 2014-12-10
* Added: Shortcut function 'get' added to db, schema and table classes.
* Fix: hasManyThrough does not return foreign keys.

###### 1.7.0 / 2014-12-10
* Added: onDelete and onUpdate added to hasMany and hasManyThrough relations.

###### 1.6.0 / 2014-12-10
* DEPRECATED: column.special function. Use column.enumValues instead.
* Added: Tests for enum values.
* Added: Enum support for column.sequelizeType function.
* Updated: Documentation

###### 1.5.1 / 2014-12-04
* Fix: Test db does not destroyed after tests.

###### 1.5.0 / 2014-12-04
* Fix: column.default() method returns default value with type cast. From now on yype cast part is stripped.
* Added column.defaultWithTypeCast() method for getting default values with type cast part.
* Tests added for default values.

###### 1.4.0 / 2014-11-28
* Added support for user-defined types.
* Added column.udType() method to get user defined type name.
* Added necessary tests.

###### 1.3.1 / 2014-11-27
* Added history to readme.
* Fix: Major error: Single schema or default 'public' schema databases throw error.
* Fix: Databases without any table throw error.
* Added tests of this fixes and table without any column.

###### 1.3.0 / 2014-11-27
* Parameter validation added to pg-structure main function. This would ease debugging.
* Fix: pg-structure.generate function was throwing error, now it calls its callback with error
if database connection error occurs.

###### 1.2.0 / 2014-11-26
* Fix: pg-structure callback does not get error object. Instead error is thrown. Now callback gets error object as its first parameter as expected.
* db.schema() function now throws more informative error if referenced schema is not found in db and also not in the options of requested schemas.
* db.schemaExist() function added.
* History.md file added. (This file)

###### 1.1.0 / 2014-11-25
* table.foreignKeyConstraintExist() function added.

###### 1.0.0 / 2014-11-25
* Completely rewritten to migrate from plain object to object oriented design.
* column.sequelizeType() method added. This method gets sequelize compatible type of the column.


LICENSE
=======

The MIT License (MIT)

Copyright (c) 2015 Özüm Eldoğan

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
